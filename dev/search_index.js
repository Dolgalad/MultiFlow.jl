var documenterSearchIndex = {"docs":
[{"location":"mcf/io.html#Reading/writing-MCFs","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"","category":"section"},{"location":"mcf/io.html#Index","page":"Reading/writing MCFs","title":"Index","text":"","category":"section"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"Pages = [\"io.md\"]","category":"page"},{"location":"mcf/io.html#MCF-file-formats","page":"Reading/writing MCFs","title":"MCF file formats","text":"","category":"section"},{"location":"mcf/io.html#Reading-CSV-files","page":"Reading/writing MCFs","title":"Reading CSV files","text":"","category":"section"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"MCF instances are stored as two CSV files, a link.csv file containing edge data and a service.csv file containing the demand data. ","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"Example of a link.csv file: ","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"|# LinkId|srcNodeId|dstNodeId|capacity |cost|latency|\n|--------|---------|---------|---------|----|-------|\n|1       |1        |4        |6        |2   |0      |\n|2       |1        |2        |12       |3   |0      |\n|3       |2        |4        |12       |3   |0      |\n|4       |4        |7        |5        |8   |0      |\n|5       |2        |3        |11       |4   |0      |\n|6       |3        |4        |20       |8   |0      |\n|7       |4        |6        |10       |3   |0      |\n|8       |6        |7        |20       |3   |0      |\n|9       |1        |5        |10       |80  |0      |\n|10      |5        |7        |10       |20  |0      |","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"Example of a service.csv file: ","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"|# DemandId|srcNodeId|dstNodeId|amount   |latency|\n|----------|---------|---------|---------|-------|\n|1         |1        |7        |5        |0      |\n|2         |2        |6        |5        |0      |\n|3         |3        |7        |5        |0      |","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"If dirname is the path of a directory containing both files as described in the example above we may load an MCF instance : ","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"julia> pb = load(dirname)\nMCF(nv = 7, ne = 10, nk = 3)\n\tDemand{Int64, Int64}(1, 7, 5)\n\tDemand{Int64, Int64}(2, 6, 5)\n\tDemand{Int64, Int64}(3, 7, 5)\n\njulia> adjacency_matrix(pb.graph)\n7×7 SparseArrays.SparseMatrixCSC{Int64, Int64} with 10 stored entries:\n ⋅  1  ⋅  1  1  ⋅  ⋅\n ⋅  ⋅  1  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  1  1\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"By default the edges in the link.csv file are added only in one direction. Ensuring that edges exist in both directions can be achieved by passing edge_dir = :double to the load function. Note that for each edge that is specified in only one direction within the CSV file, features will be copied.","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"julia> pb = load(dirname, edge_dir=:double)\nMCF(nv = 7, ne = 20, nk = 3)\n\tDemand{Int64, Int64}(1, 7, 5)\n\tDemand{Int64, Int64}(2, 6, 5)\n\tDemand{Int64, Int64}(3, 7, 5)\n\njulia> adjacency_matrix(pb.graph)\n7×7 SparseArrays.SparseMatrixCSC{Int64, Int64} with 20 stored entries:\n ⋅  1  ⋅  1  1  ⋅  ⋅\n 1  ⋅  1  1  ⋅  ⋅  ⋅\n ⋅  1  ⋅  1  ⋅  ⋅  ⋅\n 1  1  1  ⋅  ⋅  1  1\n 1  ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  1  ⋅  ⋅  1\n ⋅  ⋅  ⋅  1  1  1  ⋅","category":"page"},{"location":"mcf/io.html#Saving-instances","page":"Reading/writing MCFs","title":"Saving instances","text":"","category":"section"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"To save an MCF instance to a directory : ","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"push!(LOAD_PATH, \"../../..\") # hide\nusing Graphs, CSV, MultiFlows, DataFrames, Latexify # hide\npb = MCF(grid((3,2)), ones(Int64,7), 1:7, [Demand(1,2,2)]);\nsave(pb, \"instance\")\ndf = CSV.read(\"instance/link.csv\", DataFrame)\nmdtable(df,latex=false) # hide","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"service.csv contents : ","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"df = CSV.read(\"instance/service.csv\", DataFrame)\nmdtable(df,latex=false) # hide","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"This will create two files : path_to_instance/link.csv and path_to_instance/service.csv.","category":"page"},{"location":"mcf/io.html#Full-docs","page":"Reading/writing MCFs","title":"Full docs","text":"","category":"section"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"Modules = [MultiFlows]\nPages = [\"io.jl\"]\n","category":"page"},{"location":"mcf/io.html#MultiFlows.UnknownMultiFlowFormat","page":"Reading/writing MCFs","title":"MultiFlows.UnknownMultiFlowFormat","text":"UnknownMCFFormat Exception\n\nException raised when trying to load instance from unknown file format.\n\n\n\n\n\n","category":"type"},{"location":"mcf/io.html#MultiFlows.is_instance_dir-Tuple{String}","page":"Reading/writing MCFs","title":"MultiFlows.is_instance_dir","text":"is_instance_dir(dirname::String)\n\nCheck if a directory contains files link.csv, service.csv.\n\njulia> save(pb, \"test_instance\")\n(\"test_instance/link.csv\", \"test_instance/service.csv\")\n\njulia> is_instance_dir(\"test_instance\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"mcf/io.html#MultiFlows.load-Tuple{String}","page":"Reading/writing MCFs","title":"MultiFlows.load","text":"load(dirname::String; format=:csv, edge_dir=:single)\n\nLoad MultiFlow problem from file. If format=:csv uses load_csv(dirname::String) (at this time CSV files are the only supported format). edge_dir can be one of the following : \n\n:single : each edge in the input file is interpreted as a directed edge\n:double : each edge in the input file is interpreted as existing in both directions with the same attributes and features\n\n\n\n\n\n","category":"method"},{"location":"mcf/io.html#MultiFlows.load_csv-Tuple{String}","page":"Reading/writing MCFs","title":"MultiFlows.load_csv","text":"load_csv(dirname::String)\n\nLoad MultiFlow instance from CSV files. Default is to search for a link.csv and service.csv file.\n\n\n\n\n\n","category":"method"},{"location":"mcf/io.html#MultiFlows.save-Tuple{MCF, String}","page":"Reading/writing MCFs","title":"MultiFlows.save","text":"save(pb::MCF, dirname::String)\n\nSave MCF instance to dirname. Will create the files <dirname>/link.csv and <dirname>/service.csv. If folder does not exist it will be created.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(Int64,7), 1:7, [Demand(1,2,2)]);\n\njulia> save(pb, \"instance\")\n(\"instance/link.csv\", \"instance/service.csv\")\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/solver.html#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"mcf/solver.html#Index","page":"Solvers","title":"Index","text":"","category":"section"},{"location":"mcf/solver.html","page":"Solvers","title":"Solvers","text":"Pages = [\"solver.md\", \"heuristic_solver.md\", \"compact_solver.md\"]","category":"page"},{"location":"development.html#Installation-and-Development","page":"Installation and Development","title":"Installation and Development","text":"","category":"section"},{"location":"development.html#Installation","page":"Installation and Development","title":"Installation","text":"","category":"section"},{"location":"development.html","page":"Installation and Development","title":"Installation and Development","text":"To install and start using MultiFlows.jl first clone the repository move into the MultiFlows.jl directory and launch Julia REPL : ","category":"page"},{"location":"development.html","page":"Installation and Development","title":"Installation and Development","text":"git clone https://github.com/Dolgalad/MultiFlows.jl.git\ncd MultiFlows.jl\njulia --project","category":"page"},{"location":"development.html","page":"Installation and Development","title":"Installation and Development","text":"(MultiFlows) pkg> instantiate\n[...]\n\njulia> using MultiFlows","category":"page"},{"location":"development.html#Development","page":"Installation and Development","title":"Development","text":"","category":"section"},{"location":"development.html","page":"Installation and Development","title":"Installation and Development","text":"The dev branch is used for development purposes, new functionality should first be added to this branch. ","category":"page"},{"location":"development.html#Building-documentation","page":"Installation and Development","title":"Building documentation","text":"","category":"section"},{"location":"development.html","page":"Installation and Development","title":"Installation and Development","text":"First enter the Julia REPL environment : ","category":"page"},{"location":"development.html","page":"Installation and Development","title":"Installation and Development","text":"julia --project","category":"page"},{"location":"development.html","page":"Installation and Development","title":"Installation and Development","text":"Activate the docs sub-project : ","category":"page"},{"location":"development.html","page":"Installation and Development","title":"Installation and Development","text":"(MultiFlows) pkg> activate ./docs\n[...]\n\n(MultiFlows) pkg> dev .\n[...]\n\njulia> include(\"docs/make.jl\")\n[...]","category":"page"},{"location":"development.html","page":"Installation and Development","title":"Installation and Development","text":"or simply execute the following while in the project root directory : ","category":"page"},{"location":"development.html","page":"Installation and Development","title":"Installation and Development","text":"julia --project=./docs docs/make.jl","category":"page"},{"location":"development.html","page":"Installation and Development","title":"Installation and Development","text":"In another terminal start a local web server to serve the contents of the docs/build directory : ","category":"page"},{"location":"development.html","page":"Installation and Development","title":"Installation and Development","text":"julia --project=./docs -e 'using LiveServer ; serve(dir=\"docs/build\")'\nServer ; serve(dir=\"./docs/build\")'\n✓ LiveServer listening on http://localhost:8000/ ...\n  (use CTRL+C to shut down)\n","category":"page"},{"location":"core_functions/path.html#Paths","page":"Paths","title":"Paths","text":"","category":"section"},{"location":"core_functions/path.html#Index","page":"Paths","title":"Index","text":"","category":"section"},{"location":"core_functions/path.html","page":"Paths","title":"Paths","text":"Pages = [\"path.md\"]","category":"page"},{"location":"core_functions/path.html#Full-docs","page":"Paths","title":"Full docs","text":"","category":"section"},{"location":"core_functions/path.html","page":"Paths","title":"Paths","text":"Modules = [MultiFlows]\nPages = [\"path.jl\"]\n","category":"page"},{"location":"core_functions/path.html#MultiFlows.AbstractPath","page":"Paths","title":"MultiFlows.AbstractPath","text":"AbstractPath\n\nAbstract type for representing paths in a graph.\n\n\n\n\n\n","category":"type"},{"location":"core_functions/path.html#MultiFlows.VertexPath","page":"Paths","title":"MultiFlows.VertexPath","text":"VertexPath\n\nConcrete type for paths composed of a sequence of vertex indices.\n\nExample\n\njulia> g = grid((3,2))\n{6, 7} undirected simple Int64 graph\n\njulia> ds = dijkstra_shortest_paths(g, 1);\n\njulia> p = VertexPath(enumerate_paths(ds, 6))\nVertexPath{Int64}([1, 2, 5, 6])\n\n\n\n\n\n","category":"type"},{"location":"core_functions/path.html#Base.:==-Union{Tuple{T}, Tuple{VertexPath{T}, VertexPath{T}}} where T","page":"Paths","title":"Base.:==","text":"Base.:(==)(p1::VertexPath{T}, p2::VertexPath{T}) where {T}\n\nCheck path equality. Checks p1.vertices == p2.vertices.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/path.html#Base.isempty-Tuple{VertexPath}","page":"Paths","title":"Base.isempty","text":"Base.isempty(p::VertexPath)\n\nCheck if the path is empty.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/path.html#Base.length-Tuple{VertexPath}","page":"Paths","title":"Base.length","text":"Base.length(p::VertexPath; edges=false)\n\nReturns length of the path. Default is to return number of vertices, if edges=true returns number of edges.\n\nExample\n\njulia> p = VertexPath([1,2,3])\nVertexPath{Int64}([1, 2, 3])\n\njulia> length(p)\n3\n\njulia> length(p, edges=true)\n2\n\n\n\n\n\n","category":"method"},{"location":"core_functions/path.html#Graphs.edges-Tuple{VertexPath}","page":"Paths","title":"Graphs.edges","text":"Graphs.edges(p::VertexPath)\n\nReturn edge iterator of the path.\n\nExample\n\njulia> p = VertexPath([1,2,3])\nVertexPath{Int64}([1, 2, 3])\n\njulia> edges(p)\n2-element Vector{Tuple{Int64, Int64}}:\n (1, 2)\n (2, 3)\n\n\n\n\n\n","category":"method"},{"location":"core_functions/path.html#Graphs.has_edge-Union{Tuple{T}, Tuple{VertexPath{T}, T, T}} where T","page":"Paths","title":"Graphs.has_edge","text":"Graphs.has_edge(p::VertexPath{T}, s::T, t::T) where {T}\n\nCheck if the path contains edge (s,t).\n\nExample\n\njulia> p = VertexPath([1,2,3]);\n\njulia> has_edge(p, 1, 2)\ntrue\n\njulia> has_edge(p, 1, 3)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"core_functions/path.html#MultiFlows.edge_indices-Tuple{VertexPath, Graphs.AbstractGraph}","page":"Paths","title":"MultiFlows.edge_indices","text":"edge_indices(p::VertexPath, g::AbstractGraph)\n\nGet list of edge indices corresponding to the path.\n\nExample\n\njulia> p = VertexPath([1,2,5,6]);\n\njulia> edge_indices(p, g)\n3-element Vector{Int64}:\n 1\n 4\n 7\n\njulia> collect(edges(g))[edge_indices(p,g)]\n3-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 2 => 5\n Edge 5 => 6\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/path.html#MultiFlows.is_path-Tuple{VertexPath, Graphs.AbstractGraph}","page":"Paths","title":"MultiFlows.is_path","text":"is_path(p::VertexPath, g::AbstractGraph)\n\nCheck if p is a valid path in graph g.\n\nExample\n\njulia> g = grid((3,2));\n\njulia> p = VertexPath([1,2,5,6]);\n\njulia> is_path(p, g)\ntrue\n\njulia> is_path(p, grid((2,1)))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"core_functions/path.html#MultiFlows.is_path-Union{Tuple{T}, Tuple{VertexPath{T}, T, T}} where T","page":"Paths","title":"MultiFlows.is_path","text":"is_path(p::VertexPath{T}, s::T, t::T)\n\nCheck if path is an s-t-path.\n\nExample\n\njulia> p = VertexPath([1,2,3]);\n\njulia> is_path(p, 1, 2)\nfalse\n\njulia> is_path(p, 1, 3)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"core_functions/path.html#MultiFlows.path_from_edge_indices-Tuple{Vector{Int64}, Graphs.AbstractGraph}","page":"Paths","title":"MultiFlows.path_from_edge_indices","text":"path_from_edge_indices(ei::Vector{Int64}, g::AbstractGraph)\n\nConvert a list of edge indices to a path in graph g.\n\nExample\n\njulia> g = grid((3,3))\n{9, 12} undirected simple Int64 graph\n\njulia> p = VertexPath(enumerate_paths(dijkstra_shortest_paths(g, 1), 9))\nVertexPath{Int64}([1, 2, 5, 6, 9])\n\njulia> ei = edge_indices(p, g)\n4-element Vector{Int64}:\n  1\n  4\n  8\n 10\n\njulia> path_from_edge_indices(ei, g)\nVertexPath{Int64}([1, 2, 5, 6, 9])\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/path.html#MultiFlows.path_weight-Tuple{VertexPath, Graphs.AbstractGraph}","page":"Paths","title":"MultiFlows.path_weight","text":"path_weight(p::VertexPath, g::AbstractGraph; aggr::Function=sum, dstmx=weights(g))\n\nCompute the weight of the path in graph g. \n\nExample\n\njulia> path_weight(p, g)\n3\n\nYou may provide a different weight matrix \n\njulia> w = zeros(nv(g), nv(g));\n\njulia> w[Bool.(adjacency_matrix(g))] .= 1:2*ne(g);\n\njulia> w\n6×6 Matrix{Float64}:\n 0.0  3.0  0.0  8.0   0.0   0.0\n 1.0  0.0  6.0  0.0  10.0   0.0\n 0.0  4.0  0.0  0.0   0.0  13.0\n 2.0  0.0  0.0  0.0  11.0   0.0\n 0.0  5.0  0.0  9.0   0.0  14.0\n 0.0  0.0  7.0  0.0  12.0   0.0\n\njulia> path_weight(p, g, dstmx=w)\n27.0\n\njulia> path_weight(p, g, dstmx=w, aggr=minimum)\n3.0\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Feature-Graph","page":"Feature Graph","title":"Feature Graph","text":"","category":"section"},{"location":"core_functions/feature_graph.html","page":"Feature Graph","title":"Feature Graph","text":"Definition of the FeatureDiGraph object used for representing directed graphs with multi-dimensional features on edges.","category":"page"},{"location":"core_functions/feature_graph.html#Index","page":"Feature Graph","title":"Index","text":"","category":"section"},{"location":"core_functions/feature_graph.html","page":"Feature Graph","title":"Feature Graph","text":"Pages = [\"feature_graph.md\"]","category":"page"},{"location":"core_functions/feature_graph.html#Full-docs","page":"Feature Graph","title":"Full docs","text":"","category":"section"},{"location":"core_functions/feature_graph.html","page":"Feature Graph","title":"Feature Graph","text":"Modules = [MultiFlows]\nPages = [\"feature_graph.jl\"]\n","category":"page"},{"location":"core_functions/feature_graph.html#MultiFlows.FeatureDiGraph","page":"Feature Graph","title":"MultiFlows.FeatureDiGraph","text":"FeatureDiGraph{T,N}\n\nConcrete directed graph with a feature vector for each edge.\n\nThe default constructor expects srcnodes, dstnodes to be vectors of source and destination vertices for each edge and features to by a vector of numbers. The following example initialises a directed graph with three vertices and edges and a single Float64 feature on each edge.\n\nExamplex\n\njulia> using MultiFlows\n\njulia> g1 = FeatureDiGraph([1,2,3], [2,3,1], [5., 5., 5.])\nFeatureDiGraph{Int64, Float64}([1, 2, 3], [2, 3, 1], [5.0, 5.0, 5.0])\n\n\n\n\n\n\n","category":"type"},{"location":"core_functions/feature_graph.html#MultiFlows.FeatureDiGraph-Union{Tuple{N}, Tuple{T}, Tuple{Graphs.AbstractGraph{T}, AbstractArray{N}}} where {T<:Number, N<:Number}","page":"Feature Graph","title":"MultiFlows.FeatureDiGraph","text":"FeatureDiGraph(g::AbstractGraph{T}, features::AbstractArray{N})\n\nConstruct a feature graph from an AbstractGraph object and a set of features. If g is an undirected graph the edges will be added in both directions and features should have first dimension either ne(g) in which case features are duplicated in both directions, or 2*ne(g).\n\nExamples\n\njulia> using Graphs\n\njulia> gr = complete_digraph(5)\n{5, 20} directed simple Int64 graph\n\njulia> FeatureDiGraph(gr, ones(ne(gr), 2))\nFeatureDiGraph{Int64, Vector{Float64}}([1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5], [2, 3, 4, 5, 1, 3, 4, 5, 1, 2, 4, 5, 1, 2, 3, 5, 1, 2, 3, 4], [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0]])\n\njulia> gr = complete_graph(5)\n{5, 10} undirected simple Int64 graph\n\njulia> FeatureDiGraph(gr, ones(2*ne(gr), 2))\nFeatureDiGraph{Int64, Vector{Float64}}([1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 2, 3, 4, 5, 3, 4, 5, 4, 5, 5], [2, 3, 4, 5, 3, 4, 5, 4, 5, 5, 1, 1, 1, 1, 2, 2, 2, 3, 3, 4], [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0]])\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.FeatureDiGraph-Union{Tuple{N}, Tuple{T}, Tuple{Vector{T}, Vector{T}, AbstractArray{N}}} where {T<:Number, N<:Number}","page":"Feature Graph","title":"MultiFlows.FeatureDiGraph","text":"FeatureDiGraph(srcnodes::Vector{T}, dstnodes::Vector{T}, features::AbstractArray{N}) where {T<:Number, N<:Number}\n\nConstruct a FeatureDiGraph object where edge features are given by features[i,:].\n\nExamplex\n\nFor example we can build a graph with a two-dimensional feature on each edge : \n\njulia> g = FeatureDiGraph([1,2,3], [2,3,1], 5 * ones(3,2))\nFeatureDiGraph{Int64, Vector{Float64}}([1, 2, 3], [2, 3, 1], [[5.0, 5.0], [5.0, 5.0], [5.0, 5.0]])\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.FeatureDiGraphEdge","page":"Feature Graph","title":"MultiFlows.FeatureDiGraphEdge","text":"FeatureDiGraphEdge\n\nConcrete type representing FeatureDiGraph edges.\n\n\n\n\n\n","category":"type"},{"location":"core_functions/feature_graph.html#Base.reverse-Tuple{FeatureDiGraphEdge}","page":"Feature Graph","title":"Base.reverse","text":"\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.SimpleGraphs.add_edge!-Union{Tuple{N}, Tuple{T}, Tuple{FeatureDiGraph{T, N}, T, T, N}} where {T<:Number, N}","page":"Feature Graph","title":"Graphs.SimpleGraphs.add_edge!","text":"Graphs.add_edge!(g::FeatureDiGraph{T,N}, src::T, dst::T, feat::N}\n\nAdd edge to a FeatureDiGraph object going from vertex src to dst and with features feat. Return true on success and false if graph already has an edge (src, dst). If force=true the edge is added even if it already exists.\n\nExamples\n\njulia> g = FeatureDiGraph([1,2,3], [2,3,1], ones(3,2));\n\njulia> add_edge!(g, 1, 4, [2., 2.])\ntrue\n\njulia> add_edge!(g, 1, 2, [3., 3.])\nfalse\n\njulia> nv(g), ne(g)\n(4, 4)\n\njulia> add_edge!(g, 1, 4, ones(3)) # must have feature_dim(g) == size(feat)\nERROR: DimensionMismatch(\"Expected feature dimension (2,) got (3,)\")\n[...]\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.dst-Tuple{FeatureDiGraphEdge}","page":"Feature Graph","title":"Graphs.dst","text":"Graphs.dst(e::FeatureDiGraphEdge)\n\nGet edge destination.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.edges-Tuple{FeatureDiGraph}","page":"Feature Graph","title":"Graphs.edges","text":"edges(g::FeatureDiGraph)\n\nReturn list of edges of the graph. Needed for compatibility with Graphs.jl package.\n\nExamples\n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,4], [1,1,1,2]);\n\njulia> edges(g)\n4-element Vector{FeatureDiGraphEdge{Int64, Int64}}:\n FeatureDiGraphEdge{Int64, Int64}(1, 2, 1)\n FeatureDiGraphEdge{Int64, Int64}(2, 3, 1)\n FeatureDiGraphEdge{Int64, Int64}(3, 1, 1)\n FeatureDiGraphEdge{Int64, Int64}(1, 4, 2)\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.has_edge-Union{Tuple{N}, Tuple{T}, Tuple{FeatureDiGraph{T, N}, T, T}} where {T<:Number, N}","page":"Feature Graph","title":"Graphs.has_edge","text":"Graphs.has_edge(g::FeatureDiGraph{T,N}, s::T, d::T)\n\nCheck if graph contains edge (s,d). \n\nExamples\n\njulia> using Graphs\n\njulia> has_edge(g, 1, 2)\ntrue\n\njulia> has_edge(g, 2, 1)\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.inneighbors-Union{Tuple{N}, Tuple{T}, Tuple{FeatureDiGraph{T, N}, T}} where {T<:Number, N}","page":"Feature Graph","title":"Graphs.inneighbors","text":"Graphs.inneighbors(g::FeatureDiGraph{T,N}, v::T)\n\nGet neighbors u of vertex v such that edge (u,v) belongs to the graph. Needed for compatibility with Graphs.jl package.\n\nExamples\n\njulia> inneighbors(g, 1)\n1-element Vector{Int64}:\n 3\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.is_directed-Tuple{FeatureDiGraph}","page":"Feature Graph","title":"Graphs.is_directed","text":"Graphs.is_directed(g::FeatureDiGraph{T,N})\n\nCheck if the graph is directed, always returns true. Needed for compatibility with the Graphs.jl package.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.ne-Tuple{FeatureDiGraph}","page":"Feature Graph","title":"Graphs.ne","text":"ne(g::FeatureDiGraph)\n\nReturn number of edge of the graph. Needed for compatibility with the Graphs.jl package.\n\nExamples\n\njulia> ne(g)\n3\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.nv-Tuple{FeatureDiGraph}","page":"Feature Graph","title":"Graphs.nv","text":"nv(g::FeatureDiGraph)\n\nReturns number of vertices of the graph. Needed for compatibility with the Graphs.jl package.\n\nExamples\n\njulia> nv(g)\n3\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.outneighbors-Union{Tuple{N}, Tuple{T}, Tuple{FeatureDiGraph{T, N}, T}} where {T<:Number, N}","page":"Feature Graph","title":"Graphs.outneighbors","text":"Graphs.outneighbors(g::FeatureDiGraph{T,N}, v::T)\n\nGet outgoing neighbors of vertex v in the graph. Needed for compatibility with Graphs.jl package.\n\nExamples\n\njulia> outneighbors(g, 1)\n2-element Vector{Int64}:\n 2\n 4\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.src-Tuple{FeatureDiGraphEdge}","page":"Feature Graph","title":"Graphs.src","text":"Graphs.src(e::FeatureDiGraphEdge)\n\nGet edge source.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.weights","page":"Feature Graph","title":"Graphs.weights","text":"Graphs.weights(g::FeatureDiGraph, feature_idx::Int64=1)\n\nGet graph weight matrix corresponding to in feature with index idx. Needed for compatibility with Graphs.jl.\n\nExamples\n\njulia> using Graphs\n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,3],[[1,1],[1,1],[1,1],[4,1]])\nFeatureDiGraph{Int64, Vector{Int64}}([1, 2, 3, 1], [2, 3, 1, 3], [[1, 1], [1, 1], [1, 1], [4, 1]])\n\njulia> ds = dijkstra_shortest_paths(g, 1);\n\njulia> enumerate_paths(ds, 3)\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> ds = dijkstra_shortest_paths(g, 1, weights(g, 2));\n\njulia> enumerate_paths(ds, 3)\n2-element Vector{Int64}:\n 1\n 3\n\n\n\n\n\n","category":"function"},{"location":"core_functions/feature_graph.html#MultiFlows.convert_features-Union{Tuple{N}, Tuple{T}, Tuple{FeatureDiGraph{T, N}, DataType}} where {T, N}","page":"Feature Graph","title":"MultiFlows.convert_features","text":"convert_features(g::FeatureDiGraph{T,N}, dtype::DataType) where {T,N}\n\nConvert graph features to type dtype.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(Int64,7), 1:7, [Demand(1,2,2)]);\n\njulia> pb.graph\nFeatureDiGraph{Int64, Vector{Int64}}([1, 1, 2, 2, 3, 4, 5, 2, 4, 3, 5, 6, 5, 6], [2, 4, 3, 5, 6, 5, 6, 1, 1, 2, 2, 3, 4, 5], [[1, 1], [1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7], [1, 1], [1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7]])\n\njulia> convert_features(pb.graph, Float64)\nFeatureDiGraph{Int64, Vector{Float64}}([1, 1, 2, 2, 3, 4, 5, 2, 4, 3, 5, 6, 5, 6], [2, 4, 3, 5, 6, 5, 6, 1, 1, 2, 2, 3, 4, 5], [[1.0, 1.0], [1.0, 2.0], [1.0, 3.0], [1.0, 4.0], [1.0, 5.0], [1.0, 6.0], [1.0, 7.0], [1.0, 1.0], [1.0, 2.0], [1.0, 3.0], [1.0, 4.0], [1.0, 5.0], [1.0, 6.0], [1.0, 7.0]])\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.double_edges!-Tuple{FeatureDiGraph}","page":"Feature Graph","title":"MultiFlows.double_edges!","text":"double_edges!(g::FeatureDiGraph)\n\nFor each edge (u,v) add edge (v,u) if not already present in the graph. Features of the edge are copied.\n\nExamples\n\njulia> using Graphs\n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,3],[[1,1],[1,1],[1,1],[4,1]])\nFeatureDiGraph{Int64, Vector{Int64}}([1, 2, 3, 1], [2, 3, 1, 3], [[1, 1], [1, 1], [1, 1], [4, 1]])\n\njulia> ne(g)\n4\n\njulia> double_edges!(g)\nFeatureDiGraph{Int64, Vector{Int64}}([1, 2, 3, 1, 2, 3], [2, 3, 1, 3, 1, 2], [[1, 1], [1, 1], [1, 1], [4, 1], [1, 1], [1, 1]])\n\njulia> ne(g)\n6\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.edge_features-Tuple{FeatureDiGraph, Int64}","page":"Feature Graph","title":"MultiFlows.edge_features","text":"edge_features(g::FeatureDiGraph, idx::Int64)\n\nGet array of edge features corresponding to index idx. Returns a (ne(g), 1) array.\n\nExamples\n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,4], hcat(3*ones(4), 4*ones(4)));\n\njulia> edge_features(g, 1)\n4-element Vector{Float64}:\n 3.0\n 3.0\n 3.0\n 3.0\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.edge_features-Tuple{FeatureDiGraph}","page":"Feature Graph","title":"MultiFlows.edge_features","text":"edge_features(g::FeatureDiGraph)\n\nGet array of edge features. Returns a (ne(g), feature_dim(g)) array.\n\nExamples\n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,4], hcat(3*ones(4), 4*ones(4)));\n\njulia> edge_features(g)\n4×2 Matrix{Float64}:\n 3.0  4.0\n 3.0  4.0\n 3.0  4.0\n 3.0  4.0\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.edge_index_matrix-Union{Tuple{Graphs.AbstractGraph{T}}, Tuple{T}} where T","page":"Feature Graph","title":"MultiFlows.edge_index_matrix","text":"edge_index_matrix(g::AbstractGraph)\n\nGet (nv(g), nv(g)) sized matrix where M[i,j] is the index of edge i,j.\n\nExamples\n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,4], hcat(3*ones(4), 4*ones(4)));\n\njulia> edge_index_matrix(g)\n3×4 SparseArrays.SparseMatrixCSC{Int64, Int64} with 4 stored entries:\n ⋅  1  ⋅  4\n ⋅  ⋅  2  ⋅\n 3  ⋅  ⋅  ⋅\n\nSimple undirected graphs : \n\njulia> using Graphs\n\njulia> g = grid((3,2))\n{6, 7} undirected simple Int64 graph\n\njulia> edge_index_matrix(g)\n6×6 SparseArrays.SparseMatrixCSC{Int64, Int64} with 14 stored entries:\n ⋅  1  ⋅  2  ⋅  ⋅\n 1  ⋅  3  ⋅  4  ⋅\n ⋅  3  ⋅  ⋅  ⋅  5\n 2  ⋅  ⋅  ⋅  6  ⋅\n ⋅  4  ⋅  6  ⋅  7\n ⋅  ⋅  5  ⋅  7  ⋅\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.feature_dim-Tuple{FeatureDiGraph}","page":"Feature Graph","title":"MultiFlows.feature_dim","text":"feature_dim(g::FeatureDiGraph)\n\nGet edge feature dimension. \n\nExamplex\n\njulia> g1 = FeatureDiGraph([1,2,3], [2,3,1], ones(3));\n\njulia> feature_dim(g1) # scalar features\n()\n\njulia> g2 = FeatureDiGraph([1,2,3], [2,3,1], ones(3, 2));\n\njulia> feature_dim(g2)  # two-dimension features\n(2,)\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.feature_matrix-Tuple{FeatureDiGraph, AbstractArray{Int64}}","page":"Feature Graph","title":"MultiFlows.feature_matrix","text":"feature_matrix(g::FeatureDiGraph, feature_idx::AbstractArray{Int64})\n\nGet a nv(g) x nv(g) x size(feature_idx) matrix with coefficients equal to edge feature values corresponding to indexes in feature_idx. TODO : managing feature_idx with multiple dimensions.\n\nExamples\n\njulia> feature_matrix(g, [2, 1])\n4×4×2 Array{Float64, 3}:\n[:, :, 1] =\n 0.0  4.0  0.0  4.0\n 0.0  0.0  4.0  0.0\n 4.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n\n[:, :, 2] =\n 0.0  3.0  0.0  3.0\n 0.0  0.0  3.0  0.0\n 3.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.feature_matrix-Union{Tuple{FeatureDiGraph}, Tuple{N}, Tuple{T}, Tuple{FeatureDiGraph, Int64}} where {T<:Number, N}","page":"Feature Graph","title":"MultiFlows.feature_matrix","text":"feature_matrix(g::FeatureDiGraph, feature_idx::Int64)\n\nGet a nv(g) x nv(g) matrix with coefficients equal to edge feature values. Values returned as a sparse matrix.\n\nExamples\n\nGraph with scalar features : \n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,4], [5.0, 5.0, 5.0, 1.0]);\n\njulia> feature_matrix(g)\n4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅   5.0   ⋅   1.0\n  ⋅    ⋅   5.0   ⋅\n 5.0   ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅\n\n\nGraph with multi-dimensional features : \n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,4], hcat(3*ones(4), 4*ones(4)));\n\njulia> feature_matrix(g, 2)\n4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅   4.0   ⋅   4.0\n  ⋅    ⋅   4.0   ⋅\n 4.0   ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.scale_features-Union{Tuple{N}, Tuple{T}, Tuple{FeatureDiGraph{T, N}, N}} where {T<:Number, N}","page":"Feature Graph","title":"MultiFlows.scale_features","text":"scale_features(g::FeatureDiGraph{T,N}, factor::N)\n\nScale the features of the graph by factor. factor should have the same dimension as the edge features.\n\n\n\n\n\n","category":"method"},{"location":"solvers/solver_statistics.html#Solver-Statistics","page":"Solver Statistics","title":"Solver Statistics","text":"","category":"section"},{"location":"solvers/solver_statistics.html#Index","page":"Solver Statistics","title":"Index","text":"","category":"section"},{"location":"solvers/solver_statistics.html","page":"Solver Statistics","title":"Solver Statistics","text":"Pages = [\"solver_statistics.md\"]","category":"page"},{"location":"solvers/solver_statistics.html#Full-docs","page":"Solver Statistics","title":"Full docs","text":"","category":"section"},{"location":"solvers/solver_statistics.html","page":"Solver Statistics","title":"Solver Statistics","text":"Modules = [MultiFlows]\nPages = [\"solver_stats.jl\"]\n","category":"page"},{"location":"solvers/solver_statistics.html#MultiFlows.SolverStatistics","page":"Solver Statistics","title":"MultiFlows.SolverStatistics","text":"SolverStatistics\n\nContainer for storing solver statistics.\n\n\n\n\n\n","category":"type"},{"location":"solvers/solver_statistics.html#MultiFlows.SolverStatistics-Tuple{}","page":"Solver Statistics","title":"MultiFlows.SolverStatistics","text":"SolverStatistics()\n\nInitialize empty solver statistics.\n\n\n\n\n\n","category":"method"},{"location":"solvers/solver_statistics.html#Base.getindex-Tuple{SolverStatistics, String}","page":"Solver Statistics","title":"Base.getindex","text":"Base.getindex(ss::SolverStatistics, k::String)\n\nGet statistic corresponding to key k.\n\n\n\n\n\n","category":"method"},{"location":"solvers/solver_statistics.html#Base.setindex!-Tuple{SolverStatistics, Any, String}","page":"Solver Statistics","title":"Base.setindex!","text":"Base.setindex!(ss::SolverStatistics, v::Any, k::String)\n\nSet statistic with key k and value v.\n\n\n\n\n\n","category":"method"},{"location":"solvers/solver_statistics.html#MultiFlows.add_JuMP_statistics-Tuple{SolverStatistics, JuMP.Model}","page":"Solver Statistics","title":"MultiFlows.add_JuMP_statistics","text":"add_JuMP_statistics(ss::SolverStatistics, model::JuMP.Model)\n\nAdd statistics of a JuMP model object.\n\nFunction Description\nsolver_name Name of the LP solver used\ntermination_status Status of the solver\nsolve_time Solve time in seconds\nobjective_sense Sense of the optimization problem (min/max)\nobjective_value Objective value of the problem\nobjective_bound Objective value bound\nrelative_gap Solution relative gap\ndualobjectivevalue Dual objective value of the problem\nprimal_status Status of the primal solution\ndual_status Status of the dual solution\nnode_count Branch and bound tree node count\nsimplex_iterations Number of simplex iterations performed\nbarrier_iterations Number of barrier iterations performed\nresult_count Number of results available\n\n\n\n\n\n","category":"method"},{"location":"sparsify.html#MCF-Sparsification","page":"MCF Sparsification","title":"MCF Sparsification","text":"","category":"section"},{"location":"sparsify.html#Index","page":"MCF Sparsification","title":"Index","text":"","category":"section"},{"location":"sparsify.html","page":"MCF Sparsification","title":"MCF Sparsification","text":"Pages = [\"sparsify.md\"]","category":"page"},{"location":"sparsify.html","page":"MCF Sparsification","title":"MCF Sparsification","text":"Sparsification if the process of identifying variables that can be eliminated from the problem resulting in a smaller model that is easier to solve than the original. MCF solutions are notorious for using a very small portion of the graph from routing the demands, i.e. many of the arc-demand variables x_a^k have zero value. Properly identifying regions of the graph that either have very small or very important probability of belonging to the solution can lead to a significant increase in solver performance, but in general this is not an easy task. ","category":"page"},{"location":"sparsify.html","page":"MCF Sparsification","title":"MCF Sparsification","text":"We call a sparsifier a function gamma taking as input an MCF instance mathcalI defined over graph G=(VA) and with demands K. The sparsifier outputs a 0-1-matrix S = (s_ka)_kin K ain A = gamma (mathcalI) of dimension K times A where S_ka = 0 means that variable x_a^k can be set to 0.","category":"page"},{"location":"sparsify.html","page":"MCF Sparsification","title":"MCF Sparsification","text":"The MultiFlows.jl package offers a general framework for defining such sparsifier and integrating them into MCF problem solvers. Applications of sparsification include : ","category":"page"},{"location":"sparsify.html","page":"MCF Sparsification","title":"MCF Sparsification","text":"reducing the size of the compact formulation model\nsparsifying the pricing problem in column generation","category":"page"},{"location":"sparsify.html","page":"MCF Sparsification","title":"MCF Sparsification","text":"<img class=\"display-light-only\" src=\"./assets/img/sparsify_light.png\" alt=\"India35 Sparsification\"/>\n<img class=\"display-dark-only\" src=\"./assets/img/sparsify_dark.png\" alt=\"India35 Sparsification\"/>","category":"page"},{"location":"sparsify.html#Compact-formulation-reduction","page":"MCF Sparsification","title":"Compact formulation reduction","text":"","category":"section"},{"location":"sparsify.html","page":"MCF Sparsification","title":"MCF Sparsification","text":"The Sparse Compact Formulation of an MCF problem is defined as in Arc-flow formulation where additional constraints are added : ","category":"page"},{"location":"sparsify.html","page":"MCF Sparsification","title":"MCF Sparsification","text":"x_a^k = 0 quad forall k in K ain A s_ka = 0","category":"page"},{"location":"sparsify.html","page":"MCF Sparsification","title":"MCF Sparsification","text":"The resulting problem is solved using state of the art solvers. ","category":"page"},{"location":"sparsify.html#MCF-Pricing-sparsification","page":"MCF Sparsification","title":"MCF Pricing sparsification","text":"","category":"section"},{"location":"sparsify.html","page":"MCF Sparsification","title":"MCF Sparsification","text":"For MCF problems the pricing problem involes searching for each demand k a shortest-path. Although shortest-paths algorithms are efficient they may spend unnecessary time visiting parts of the graph that could not possibly belong to the solution. Reducing the graph size for each demand such that it only contains promising arcs can lead to performance increase without degrading the quality of the solution.","category":"page"},{"location":"sparsify.html","page":"MCF Sparsification","title":"MCF Sparsification","text":"Given a demand k we define the sparse graph G_k = (V A_k) where A_k = a in A  s_ka = 1 . G_k is then used for solving the pricing problem. ","category":"page"},{"location":"sparsify.html#Sparsification-methods","page":"MCF Sparsification","title":"Sparsification methods","text":"","category":"section"},{"location":"sparsify.html","page":"MCF Sparsification","title":"MCF Sparsification","text":"Some sparsification techniques that we have implemented : ","category":"page"},{"location":"sparsify.html","page":"MCF Sparsification","title":"MCF Sparsification","text":"SP sparsification : for each k we set s_ka = 1 if a belongs to at least one of the L s_kt_k-shortest-paths. This requires either computing at solve time L shortest-paths for each demand or knowing such paths in advance.\nML sparsification : an sparsification model can be trained by supervised learning to approximately identify promising parts of the graph. ","category":"page"},{"location":"sparsify.html#Full-docs","page":"MCF Sparsification","title":"Full docs","text":"","category":"section"},{"location":"sparsify.html","page":"MCF Sparsification","title":"MCF Sparsification","text":"Modules = [MultiFlows]\nPages = [\"sparsify.jl\"]\n","category":"page"},{"location":"sparsify.html#MultiFlows.AbstractSparsifier","page":"MCF Sparsification","title":"MultiFlows.AbstractSparsifier","text":"AbstractSparsifier\n\nAbstract type shared by all Sparsifier models. These are objects who implement the sparsify(sprs::AbstractSparsifier, pb::MCF) that returns a (nk(pb), ne(pb)) 0-1-matrix where if M[k,a]==1 arc a is classifier as being used to route demand k\n\n\n\n\n\n","category":"type"},{"location":"sparsify.html#MultiFlows.SPSparsifier","page":"MCF Sparsification","title":"MultiFlows.SPSparsifier","text":"SPSparsifier\n\nShortest Path Sparsifier. For each demand will keep only arcs belonging to the k shortest paths.\n\n\n\n\n\n","category":"type"},{"location":"sparsify.html#MultiFlows.sparsify-Tuple{MultiFlows.AbstractSparsifier, MCF}","page":"MCF Sparsification","title":"MultiFlows.sparsify","text":"sparsify(sprs::AbstractSparsifier, pb::MCF)\n\nProduces the arc-demand classification result. This function needs to be defined for each type of sparsifier.\n\n\n\n\n\n","category":"method"},{"location":"sparsify.html#MultiFlows.sparsify-Tuple{MultiFlows.SPSparsifier, MCF}","page":"MCF Sparsification","title":"MultiFlows.sparsify","text":"sparsify(sprs::SPSparsifier, pb::MCF)\n\nSparsify the MCF pb.\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#Multi-Commodity-Flow","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"","category":"section"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"MultiFlows.jl offers the MCF interface for creating Multi-Commodity Flow problems. An MCF instance is defined by a capacitated graph and a set of demands. The objective is to find a set of paths that satisfy the demands without exceeding edge capacities.","category":"page"},{"location":"mcf/mcf.html#Formulation","page":"Multi-Commodity Flow","title":"Formulation","text":"","category":"section"},{"location":"mcf/mcf.html#Arc-flow-formulation","page":"Multi-Commodity Flow","title":"Arc-flow formulation","text":"","category":"section"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"The problem is defined on a directed graph G = (V A) with edge costs r_a in mathbbR^+ and capacities c_a in mathbbR^+. We are given a set of demands K with each demand having an origin and destination s_k t_k in V and an amount b_k in mathbbR^+. Denoting by x_a^k in 0 1 the amount of flow for demand k circulating through edge a the problem can be written : ","category":"page"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"beginaligned\nminlimits  sumlimits_k in K sumlimits_ain A b_k r_a x_a^k   (1) \ntextst sumlimits_a in delta^+(v) x_a^k - sumlimits_aindelta^-(v) x_a^k = left beginarrayrl 1  textif  v=s_k  -1  textif  v=t_k  0  textotherwise endarray right  forall kin K vin V quad  (2)\nsumlimits_kin K b_k x_a^k leq c_a  forall a in A quad  (3)\nx_a^k in 0 1  forall kin K ain A quad  (4)\nendaligned","category":"page"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"delta^-(u) delta^+(u) respectively denote the set of incomming and outgoing edges at vertex u. Constraint (2) are flow conservation constraints and (3) the edge capacity constraints. When replacing (4) by integer constraints x_a^k in 0 1 we refer to this problem as the Unsplittable Multi-Commodity Flow problem, demands must then by fully routed on a single path.","category":"page"},{"location":"mcf/mcf.html#Path-flow-formulation","page":"Multi-Commodity Flow","title":"Path-flow formulation","text":"","category":"section"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"For each k in K we defined P^k the set of s_k-t_k-paths composed of edges with capacity geater than b_k. For each p in P^k we denote x_p^k the amount of flow circulating on p for demand k. Let P_a^k subset P^k the set of paths that pass through edge a. The Path-flow formulation of the problem is then : ","category":"page"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"beginaligned\nminlimits  sumlimits_k in K sumlimits_pin P^k sumlimits_ain p b_k r_a x_p^k   (5) \ntextst sumlimits_pin P^k x_p^k  = 1  forall kin K quad  (6)\nsumlimits_kin K sumlimits_pin P^k_a b_k x_p^k leq c_a  forall a in A quad  (7)\nx_p^k in 0 1  forall kin K pin P^k quad  (8)\nendaligned","category":"page"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"Constraint (6) ensures that the totality of b_k is routed and (7) that the edge capacities are not exceeded.","category":"page"},{"location":"mcf/mcf.html#Index","page":"Multi-Commodity Flow","title":"Index","text":"","category":"section"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"Pages = [\"mcf.md\"]","category":"page"},{"location":"mcf/mcf.html#Full-docs","page":"Multi-Commodity Flow","title":"Full docs","text":"","category":"section"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"Modules = [MultiFlows]\nPages = [\"demand.jl\", \"mcf.jl\", \"solution.jl\"]\n","category":"page"},{"location":"mcf/mcf.html#MultiFlows.AbstractDemand","page":"Multi-Commodity Flow","title":"MultiFlows.AbstractDemand","text":"AbstractDemand\n\nAbstract type subtyped for creating MCF demands.\n\n\n\n\n\n","category":"type"},{"location":"mcf/mcf.html#MultiFlows.Demand","page":"Multi-Commodity Flow","title":"MultiFlows.Demand","text":"MCFDemand\n\nConcrete demand type for MCF problems. A demand has a source node src, destination node dst and an amount amount.\n\n\n\n\n\n","category":"type"},{"location":"mcf/mcf.html#MultiFlows.MCF","page":"Multi-Commodity Flow","title":"MultiFlows.MCF","text":"MCF\n\nMulti-Commodity Flow problem data container. The default expects graph to be a FeatureDiGraph object with 2-dimension edge features [cost, capacity]. demands must be a list of Demand objects.\n\nExamples\n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,3], ones(4,2))\nFeatureDiGraph{Int64, Vector{Float64}}([1, 2, 3, 1], [2, 3, 1, 3], [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0]])\n\njulia> MCF(g, [Demand(1, 2, 1.0)])\nMCF(nv = 3, ne = 4, nk = 1)\n\tDemand{Int64, Float64}(1, 2, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"mcf/mcf.html#MultiFlows.MCF-Union{Tuple{N}, Tuple{T}, Tuple{Graphs.AbstractGraph{T}, AbstractVector{N}, AbstractVector{N}, Array{Demand{T, N}, 1}}} where {T<:Number, N<:Number}","page":"Multi-Commodity Flow","title":"MultiFlows.MCF","text":"MCF(g::AbstractGraph{T}, cost::AbstractVector{N}, capacity::AbstractVector{N}, demands::Vector{Demand{T,N})\n\nCreate a MCF object from an AbstractGraph object, a cost and capacity vector with length ne(g) and a set of demands.\n\nExamples\n\njulia> using Graphs\n\njulia> gr = grid((3,2));\n\njulia> MCF(gr, ones(ne(gr)), ones(ne(gr)), [Demand(1,6,1.0)])\nMCF(nv = 6, ne = 14, nk = 1)\n\tDemand{Int64, Float64}(1, 6, 1.0)\n\ncost, capacity vectors must have same length as ne(gr) : \n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#Base.show-Tuple{IO, MCF}","page":"Multi-Commodity Flow","title":"Base.show","text":"Base.show(io::IO, pb::MCF)\n\nShow MCF object.\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#Graphs.ne-Tuple{MCF}","page":"Multi-Commodity Flow","title":"Graphs.ne","text":"ne(pb::MCF)\n\nNumber of edges in the MCF network.\n\nExamples\n\njulia> ne(pb)\n14\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#Graphs.nv-Tuple{MCF}","page":"Multi-Commodity Flow","title":"Graphs.nv","text":"nv(pb::MCF)\n\nNumber of vertices.\n\nExamples\n\njulia> nv(pb)\n6\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.add_demand!-Union{Tuple{N}, Tuple{T}, Tuple{MCF{T, N}, Demand{T, N}}} where {T, N}","page":"Multi-Commodity Flow","title":"MultiFlows.add_demand!","text":"add_demand!(pb::MCF{T,N}, s::T, t::T, a::N) where {T,N}\nadd_demand!(pb::MCF{T,N}, demand::Demand{N}) where {T,N}\n\nAdd a demand to the problem.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(7), ones(7), Demand{Int64,Float64}[])\nMCF(nv = 6, ne = 14, nk = 0)\n\njulia> add_demand!(pb, 1, 2, 1.0)\n1-element Vector{Demand{Int64, Float64}}:\n Demand{Int64, Float64}(1, 2, 1.0)\n\njulia> add_demand!(pb, Demand(4, 2, 1.0))\n2-element Vector{Demand{Int64, Float64}}:\n Demand{Int64, Float64}(1, 2, 1.0)\n Demand{Int64, Float64}(4, 2, 1.0)\n\njulia> pb\nMCF(nv = 6, ne = 14, nk = 2)\n\tDemand{Int64, Float64}(1, 2, 1.0)\n\tDemand{Int64, Float64}(4, 2, 1.0)\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.aggregate_demands-Union{Tuple{MCF{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Multi-Commodity Flow","title":"MultiFlows.aggregate_demands","text":"aggregate_demands(pb::MCF)\n\nCreate new instance with aggregated demands : if demands k_1 k_2 are such that s_k_1 = s_k_2 and t_k_1 = t_k_2 they are removed from the problem and a new demand k with b_k = b_k_1 + b_k_2 and same endpoints is added.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(7), ones(7), [Demand(1,3,1.), Demand(1,3,1.)])\nMCF(nv = 6, ne = 14, nk = 2)\n\tDemand{Int64, Float64}(1, 3, 1.0)\n\tDemand{Int64, Float64}(1, 3, 1.0)\n\njulia> aggregate_demands(pb)\nMCF(nv = 6, ne = 14, nk = 1)\n\tDemand{Int64, Float64}(1, 3, 2.0)\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.capacities-Tuple{MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.capacities","text":"capacities(pb::MCF)\n\nReturn edge capacities in a Vector.\n\nExample\n\njulia> x, y = rand(14), rand(14);\n\njulia> pb = MCF(grid((3,2)), x, y, [Demand(1,2,1.)]);\n\njulia> capacities(pb) == y\ntrue\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.capacity_matrix-Tuple{MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.capacity_matrix","text":"capacity_matrix(pb::MCF)\n\nReturn a sparse matrix with dimension (nv(pb), nv(pb)) with values equal to arc capacity.\n\nExamples\n\njulia> capacity_matrix(pb)\n6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 14 stored entries:\n  ⋅   2.0   ⋅   2.0   ⋅    ⋅\n 2.0   ⋅   2.0   ⋅   2.0   ⋅\n  ⋅   2.0   ⋅    ⋅    ⋅   2.0\n 2.0   ⋅    ⋅    ⋅   2.0   ⋅\n  ⋅   2.0   ⋅   2.0   ⋅   2.0\n  ⋅    ⋅   2.0   ⋅   2.0   ⋅\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.cost_matrix-Tuple{MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.cost_matrix","text":"cost_matrix(pb::MCF)\n\nReturn a sparse matrix with dimension (nv(pb), nv(pb)) with values equal to arc costs.\n\nExamples\n\njulia> cost_matrix(pb)\n6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 14 stored entries:\n  ⋅   1.0   ⋅   1.0   ⋅    ⋅ \n 1.0   ⋅   1.0   ⋅   1.0   ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅   1.0\n 1.0   ⋅    ⋅    ⋅   1.0   ⋅ \n  ⋅   1.0   ⋅   1.0   ⋅   1.0\n  ⋅    ⋅   1.0   ⋅   1.0   ⋅ \n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.costs-Tuple{MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.costs","text":"costs(pb::MCF)\n\nReturn edge costs in a Vector.\n\nExample\n\njulia> x, y = rand(14), rand(14);\n\njulia> pb = MCF(grid((3,2)), x, y, [Demand(1,2,1.)]);\n\njulia> costs(pb) == x\ntrue\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.demand_amounts-Tuple{MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.demand_amounts","text":"demand_amounts(pb::MCF)\n\nReturn a vector of the demand amounts.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(7), ones(7), [Demand(1,2,1.), Demand(1,3,.5)]);\n\njulia> demand_amounts(pb)\n2-element Vector{Float64}:\n 1.0\n 0.5\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.demand_endpoints-Union{Tuple{MCF{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Multi-Commodity Flow","title":"MultiFlows.demand_endpoints","text":"demand_endpoints(pb::MCF)\n\nReturn vector of source and destination nodes for each demand.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(7), ones(7), [Demand(1,2,1.), Demand(1,3,.5)]);\n\njulia> demand_endpoints(pb)\n([1, 1], [2, 3])\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.demands-Union{Tuple{N}, Tuple{T}, Tuple{MCF{T, N}, T, T}} where {T, N}","page":"Multi-Commodity Flow","title":"MultiFlows.demands","text":"demands(pb::MCF{T,N}, s::T, t::T)\n\nGet demands with origin and destination s,t.\n\nExample\n\njulia> demands(pb, 1, 2)\n1-element Vector{Demand{Int64, Float64}}:\n Demand{Int64, Float64}(1, 2, 1.0)\n\njulia> demands(pb, 2, 1)\nDemand{Int64, Float64}[]\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.get_path-Union{Tuple{N}, Tuple{T}, Tuple{MCF{T, N}, T, T}} where {T, N}","page":"Multi-Commodity Flow","title":"MultiFlows.get_path","text":"get_path(pb::MCF{T,N}, s::T, t::T; \n         alg::Function=(s,t)->enumerate_paths(dijkstra_shortest_paths(pb.graph, s), t)\n        ) where {T,N}\n\nGet path from s to t for MCF problem pb.\n\nExample\n\njulia> get_path(pb, 1, 6)\nVertexPath{Int64}([1, 2, 5, 6])\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.has_demand-Union{Tuple{N}, Tuple{T}, Tuple{MCF{T, N}, T, T}} where {T, N}","page":"Multi-Commodity Flow","title":"MultiFlows.has_demand","text":"has_demand(pb::MCF{T,N}, s::T, d::T)\n\nCheck if problem has a demand originating at vertex s and with destination d.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(7), ones(7), [Demand(1,2,1.)]);\n\njulia> has_demand(pb, 1, 2)\ntrue\n\njulia> has_demand(pb, 2, 1)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.nk-Tuple{MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.nk","text":"nk(pb::MCF)\n\nNumber of demands in the MCF instance.\n\nExamples\n\njulia> nk(pb)\n1\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.normalize-Tuple{MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.normalize","text":"normalize(pb::MCF)\n\nNormalize MCF instance. Costs are scaled by 1 / max(pb.cost), capacity and demand amount are scaled by 1 / max(max(pb.capacity), max(pb.amount)).\n\nExample\n\njulia> pb = MCF(grid((3,2)), collect(1.0:7.0), collect(0.0:2:13.0), [Demand(1,6,10.0)])\nMCF(nv = 6, ne = 14, nk = 1)\n\tDemand{Int64, Float64}(1, 6, 10.0)\n\njulia> pbn = normalize(pb)\nMCF(nv = 6, ne = 14, nk = 1)\n\tDemand{Int64, Float64}(1, 6, 0.8333333333333333)\n\njulia> cost_matrix(pbn)\n6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 14 stored entries:\n  ⋅        0.142857   ⋅        0.285714   ⋅         ⋅ \n 0.142857   ⋅        0.428571   ⋅        0.571429   ⋅ \n  ⋅        0.428571   ⋅         ⋅         ⋅        0.714286\n 0.285714   ⋅         ⋅         ⋅        0.857143   ⋅ \n  ⋅        0.571429   ⋅        0.857143   ⋅        1.0\n  ⋅         ⋅        0.714286   ⋅        1.0        ⋅ \n\njulia> capacity_matrix(pbn)\n6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 14 stored entries:\n  ⋅        0.0        ⋅        0.166667   ⋅         ⋅ \n 0.0        ⋅        0.333333   ⋅        0.5        ⋅ \n  ⋅        0.333333   ⋅         ⋅         ⋅        0.666667\n 0.166667   ⋅         ⋅         ⋅        0.833333   ⋅ \n  ⋅        0.5        ⋅        0.833333   ⋅        1.0\n  ⋅         ⋅        0.666667   ⋅        1.0        ⋅ \n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.scale-Union{Tuple{MCF{T, N}}, Tuple{N}, Tuple{T}, Tuple{MCF{T, N}, Any}, Tuple{MCF{T, N}, Any, Any}} where {T, N}","page":"Multi-Commodity Flow","title":"MultiFlows.scale","text":"scale(pb::MCF, cost_factor=1.0, capacity_factor=1.0)\n\nReturn a new MCF instance with costs scaled by a cost_factor, capacity and demand amounts scaled by capacity_factor.\n\nExample\n\njulia> pb1 = scale(pb, 1.5, 3)\nMCF(nv = 6, ne = 14, nk = 1)\n\tDemand{Int64, Float64}(1, 6, 3.0)\n\njulia> cost_matrix(pb1)\n6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 14 stored entries:\n  ⋅   1.5   ⋅   1.5   ⋅    ⋅\n 1.5   ⋅   1.5   ⋅   1.5   ⋅\n  ⋅   1.5   ⋅    ⋅    ⋅   1.5\n 1.5   ⋅    ⋅    ⋅   1.5   ⋅\n  ⋅   1.5   ⋅   1.5   ⋅   1.5\n  ⋅    ⋅   1.5   ⋅   1.5   ⋅\n\n\njulia> capacity_matrix(pb1)\n6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 14 stored entries:\n  ⋅   6.0   ⋅   6.0   ⋅    ⋅\n 6.0   ⋅   6.0   ⋅   6.0   ⋅\n  ⋅   6.0   ⋅    ⋅    ⋅   6.0\n 6.0   ⋅    ⋅    ⋅   6.0   ⋅\n  ⋅   6.0   ⋅   6.0   ⋅   6.0\n  ⋅    ⋅   6.0   ⋅   6.0   ⋅\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.scale_demands-Tuple{MCF, Any}","page":"Multi-Commodity Flow","title":"MultiFlows.scale_demands","text":"scale_demands(pb::MCF, factor)\n\nScale the amount of the demands by factor. Returns new list of demands.\n\nExample\n\njulia> dems = scale_demands(pb, 2)\n1-element Vector{Demand{Int64, Float64}}:\n Demand{Int64, Float64}(1, 6, 2.0)\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.weight_matrix","page":"Multi-Commodity Flow","title":"MultiFlows.weight_matrix","text":"weight_matrix(pb::MCF, idx::Int64=1)\n\nReturns a (nv(pb), nv(pb)) matrix with elements equal to edge features corresponding to idx.\n\nExamples\n\njulia> pb = MCF(grid((3,2)), ones(7), 2*ones(7), [Demand(1,6,1.0)]);\n\njulia> weight_matrix(pb)\n6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 14 stored entries:\n  ⋅   1.0   ⋅   1.0   ⋅    ⋅\n 1.0   ⋅   1.0   ⋅   1.0   ⋅\n  ⋅   1.0   ⋅    ⋅    ⋅   1.0\n 1.0   ⋅    ⋅    ⋅   1.0   ⋅\n  ⋅   1.0   ⋅   1.0   ⋅   1.0\n  ⋅    ⋅   1.0   ⋅   1.0   ⋅\n\n\n\n\n\n\n\n","category":"function"},{"location":"mcf/mcf.html#MultiFlows.MCFSolution","page":"Multi-Commodity Flow","title":"MultiFlows.MCFSolution","text":"MCFSolution\n\nContainer representing the solution of an MCF problem. Contains a list of paths such that sol.paths[k] contains the paths used to route demand k and flows[k] are the flow values\n\n\n\n\n\n","category":"type"},{"location":"mcf/mcf.html#Base.:==-Tuple{MCFSolution, MCFSolution}","page":"Multi-Commodity Flow","title":"Base.:==","text":"Base.:(==)(s1::MCFSolution, s2::MCFSolution)\n\nCheck solution equality. Checks s1.paths==s2.paths and s1.flows==s2.flows.\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#Base.show-Tuple{IO, MCFSolution}","page":"Multi-Commodity Flow","title":"Base.show","text":"Base.show(sol::MCFSolution)\n\nShow solutions.\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#FileIO.save-Tuple{MCFSolution, String}","page":"Multi-Commodity Flow","title":"FileIO.save","text":"FileIO.save(sol::MCFSolution, filename::String)\n\nSave solution to file. Uses JLD2.jl for writing data to file.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(Int64,7), 1:7, [Demand(1,2,2)]);\n\njulia> sol,_ = solve_column_generation(pb);\n\njulia> FileIO.save(sol, \"sol.jld2\")\n\njulia> isfile(\"sol.jld2\")\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#Graphs.has_edge-Union{Tuple{T}, Tuple{MCFSolution, Int64, T, T}} where T","page":"Multi-Commodity Flow","title":"Graphs.has_edge","text":"Graphs.has_edge(sol::MCFSolution, k::Int64, s::T, t::T) where {T}\n\nCheck if the solution uses edge (s,t) for demand k.\n\nExample\n\njulia> sol = MCFSolution([[VertexPath([1,2])], [VertexPath([1,4,5,2])]], [[.5], [.5]]);\n\njulia> has_edge(sol, 1, 1, 2)\ntrue\n\njulia> has_edge(sol, 1, 5, 4)\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#Graphs.has_edge-Union{Tuple{T}, Tuple{MCFSolution, T, T}} where T","page":"Multi-Commodity Flow","title":"Graphs.has_edge","text":"Graphs.has_edge(sol::MCFSolution, s::T, t::T) where {T}\n\nCheck if the solution uses edge (s,t).\n\nExample\n\njulia> sol = MCFSolution([[VertexPath([1,2])], [VertexPath([1,4,5,2])]], [[.5], [.5]]);\n\njulia> has_edge(sol, 1, 2)\ntrue\n\njulia> has_edge(sol, 5, 4)\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.arc_flow_value-Tuple{MCFSolution, MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.arc_flow_value","text":"arc_flow_value(sol::MCFSolution, pb::MCF)\n\nReturns a (nk(pb), ne(pb)) sized matrix where coefficients x[k,a] is the amount of flow for demand k circulating through a.\n\nExample\n\njulia> pb = MCF(grid((3,2)), collect(1:7.), collect(10:16.), [Demand(1,2,1.)]);\n\njulia> sol = MCFSolution([[VertexPath([1,2]), VertexPath([1,4,5,2])]], [[.5, .5]]);\n\njulia> arc_flow_value(sol, pb)\n1×14 Matrix{Float64}:\n 0.5  0.5  0.0  0.0  0.0  0.5  0.0  0.0  0.0  0.0  0.5  0.0  0.0  0.0\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.available_capacity-Tuple{MCFSolution, MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.available_capacity","text":"available_capacity(sol::MCFSolution, pb::MCF)\n\nCompute available capacities on the graph for a given solution. \n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(14), ones(14), [Demand(1,2,1.)]);\n\njulia> sol = MCFSolution([[VertexPath([1,4,5,2])]], [[1.]]);\n\njulia> available_capacity(sol, pb)\n14-element Vector{Float64}:\n 1.0\n 0.0\n 1.0\n 1.0\n 1.0\n 0.0\n 1.0\n 1.0\n 1.0\n 1.0\n 0.0\n 1.0\n 1.0\n 1.0\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.is_feasible-Tuple{MCFSolution, MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.is_feasible","text":"is_feasible(sol::MCFSolution, pb::MCF)\n\nCheck if the solution is feasible, has to be a valid solution for the problem and the total amount circulating on the graph must not be greater than the edge capacities and all demands must be routed entirely.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(14), ones(14), [Demand(1,2,2.)]);\n\njulia> sol = MCFSolution([[VertexPath([1,4,5,2])]], [[1.]]);\n\njulia> is_feasible(sol, pb)\nfalse\n\njulia> sol = MCFSolution([[VertexPath([1,2]), VertexPath([1,4,5,2])]], [[.5, .5]]);\n\njulia> is_feasible(sol, pb)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.is_solution-Tuple{MCFSolution, MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.is_solution","text":"is_solution(sol::MCFSolution, pb::MCF)\n\nCheck if sol is a solution for problem pb. Checks if length(paths) == length(flows) == nk(pb), that each path is a valid path on the graph and has the correct endpoints, and that sum(flows[k]) <= 1.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(7), ones(7), [Demand(1,2,1.)])\nMCF(nv = 6, ne = 14, nk = 1)\n\tDemand{Int64, Float64}(1, 2, 1.0)\n\njulia> sol = MCFSolution([[VertexPath([1,2])]], [[1.]])\nMCFSolution\n\tDemand k = 1\n\t\t1.0 on VertexPath{Int64}([1, 2])\n\njulia> is_solution(sol, pb)\ntrue\n\njulia> sol = MCFSolution([[VertexPath([1,2]), VertexPath([1,4,5,2])]], [[.5, .5]])\nMCFSolution\n\tDemand k = 1\n\t\t0.5 on VertexPath{Int64}([1, 2])\n\t\t0.5 on VertexPath{Int64}([1, 4, 5, 2])\n\njulia> is_solution(sol, pb)\ntrue\n\n\nLets create invalid solutions : \n\njulia> # path is not valid\n\njulia> is_solution(MCFSolution([[VertexPath([1,3])]], [[1.]]), pb)\nfalse\n\njulia> # total flow for demand 1 is greater than 1\n\njulia> is_solution(MCFSolution([[VertexPath([1,2])]], [[2.]]), pb)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.load_solution-Tuple{String}","page":"Multi-Commodity Flow","title":"MultiFlows.load_solution","text":"load_solution(filename::String)\n\nLoad MCFSolution from JLD2 data file.\n\nExample\n\njulia> sol = load_solution(\"sol.jld2\")\nMCFSolution\n\tDemand k = 1\n\t\t0.5 on VertexPath{Int64}([1, 2])\n\t\t0.5 on VertexPath{Int64}([1, 4, 5, 2])\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.objective_value-Tuple{MCFSolution, MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.objective_value","text":"objective_value(sol::MCFSolution, pb::MCF)\n\nCompute the objective value of sol. \n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(14), ones(14), [Demand(1,2,2.)]);\n\njulia> sol = MCFSolution([[VertexPath([1,4,5,2])]], [[1.]]);\n\njulia> objective_value(sol, pb)\n6.0\n\njulia> sol = MCFSolution([[VertexPath([1,2]), VertexPath([1,4,5,2])]], [[.5, .5]]);\n\njulia> objective_value(sol, pb)\n4.0\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.path_capacity-Tuple{VertexPath, MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.path_capacity","text":"path_capacity(p::VertexPath, pb::MCF)\n\nGet minimum capacity of arcs belonging to path p.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(Int64,7), 1:7, [Demand(1,2,2)]);\n\njulia> p = get_path(pb, 1, 6)\nVertexPath{Int64}([1, 2, 5, 6])\n\njulia> path_capacity(p, pb)\n1\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.paths-Tuple{MCFSolution, Int64}","page":"Multi-Commodity Flow","title":"MultiFlows.paths","text":"paths(sol::MCFSolution, k::Int64)\n\nReturn paths used in the solution with non-zero flow for demand k.\n\nExample\n\njulia> sol = MCFSolution([[VertexPath([1,2])], [VertexPath([1,4,5,2])]], [[.5], [.5]]);\n\njulia> paths(sol, 1)\n1-element Vector{VertexPath{Int64}}:\n VertexPath{Int64}([1, 2])\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.paths-Tuple{MCFSolution}","page":"Multi-Commodity Flow","title":"MultiFlows.paths","text":"paths(sol::MCFSolution)\n\nReturn all paths used in the solution with non-zero flow.\n\nExample\n\njulia> sol = MCFSolution([[VertexPath([1,2]), VertexPath([1,4,5,2])]], [[.5, .5]]);\n\njulia> paths(sol)\n2-element Vector{VertexPath{Int64}}:\n VertexPath{Int64}([1, 2])\n VertexPath{Int64}([1, 4, 5, 2])\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.paths_from_arc_flow_values-Tuple{Vector, Int64, MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.paths_from_arc_flow_values","text":"paths_from_arc_flow_values(x::Vector, k::Int64, pb::MCF)\n\nCompute paths and flows from arc flow values.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(14), ones(14), [Demand(1,2,2.)]);\n\njulia> sol = MCFSolution([[VertexPath([1,4,5,2])]], [[1.]]);\n\njulia> x = arc_flow_value(sol, pb)\n1×14 Matrix{Float64}:\n 0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0\n\njulia> paths_from_arc_flow_values(x[1,:], 1, pb)\n(VertexPath[VertexPath{Int64}([1, 4, 5, 2])], [1.0])\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.solution_from_arc_flow_values-Tuple{AbstractMatrix{Float64}, MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.solution_from_arc_flow_values","text":"from_arc_flow_values(x::AbstractMatrix{Float64}, pb::MCF)\n\nCompute solution paths from x_a^k values.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(14), ones(14), [Demand(1,2,2.)]);\n\njulia> sol = MCFSolution([[VertexPath([1,4,5,2])]], [[1.]]);\n\njulia> x = arc_flow_value(sol, pb)\n1×14 Matrix{Float64}:\n 0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0\n\njulia> solution_from_arc_flow_values(x, pb)\nMCFSolution\n\tDemand k = 1\n\t\t1.0 on VertexPath{Int64}([1, 4, 5, 2])\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.used_capacity-Tuple{MCFSolution, MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.used_capacity","text":"used_capacity(sol::MCFSolution, pb::MCF)\n\nCompute total edge capacity used by the solution.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(14), ones(14), [Demand(1,2,1.)]);\n\njulia> sol = MCFSolution([[VertexPath([1,4,5,2])]], [[1.]]);\n\njulia> used_capacity(sol, pb)\n14-element Vector{Float64}:\n 0.0\n 1.0\n 0.0\n 0.0\n 0.0\n 1.0\n 0.0\n 0.0\n 0.0\n 0.0\n 1.0\n 0.0\n 0.0\n 0.0\n\n\n\n\n\n\n","category":"method"},{"location":"solvers/compact_solver.html#Solving-Compact-Formulation","page":"Solving Compact Formulation","title":"Solving Compact Formulation","text":"","category":"section"},{"location":"solvers/compact_solver.html","page":"Solving Compact Formulation","title":"Solving Compact Formulation","text":"push!(LOAD_PATH, \"../../..\")\nusing Graphs, MultiFlows, Compose, GraphPlot\ng = grid((3,3))\nloc_x, loc_y = spring_layout(g)\npb = MCF(g, ones(ne(g)), ones(ne(g)), [Demand(1,9,1.0), Demand(1,6,1.0)])\ndraw(PNG(\"grid3x3_problem.png\", 16cm, 16cm), mcfplot(pb, loc_x, loc_y))\n\n# default config\nsol, ss = solve_compact(pb)\ndraw(PNG(\"grid3x3_solution.png\", 16cm, 16cm), mcfsolplot(sol, pb, loc_x, loc_y))\n\n# max acceptance\nadd_demand!(pb, Demand(1,7,1.0))\ndraw(PNG(\"grid3x3_problem_1.png\", 16cm, 16cm), mcfplot(pb, loc_x, loc_y))\nsol, ss = solve_compact(pb, max_acceptance=true)\ndraw(PNG(\"grid3x3_solution_ma.png\", 16cm, 16cm), mcfsolplot(sol, pb, loc_x, loc_y))","category":"page"},{"location":"solvers/compact_solver.html","page":"Solving Compact Formulation","title":"Solving Compact Formulation","text":"Solving Compact Formulation with state of the art LP solver. Interfacing with solver is done using the JuMP.jl package.","category":"page"},{"location":"solvers/compact_solver.html","page":"Solving Compact Formulation","title":"Solving Compact Formulation","text":"First define a simple MCF problem : ","category":"page"},{"location":"solvers/compact_solver.html","page":"Solving Compact Formulation","title":"Solving Compact Formulation","text":"julia> using Graphs, MultiFlows\n\njulia> g = grid((3,3))\n{9, 12} undirected simple Int64 graph\n\njulia> pb = MCF(gr, ones(ne(g)), ones(ne(g)), [Demand(1,9,1.0), Demand(1,6,1.0)])\nMCF(nv = 9, ne = 24, nk = 2)\n\tDemand{Int64, Float64}(1, 9, 1.0)\n\tDemand{Int64, Float64}(1, 6, 1.0)\n\njulia> solve_compact(pb)\nMCFSolution\n\tDemand k = 1\n\t\t1.0 on VertexPath{Int64}([1, 2, 5, 8, 9])\n\tDemand k = 2\n\t\t1.0 on VertexPath{Int64}([1, 4, 5, 6])\n","category":"page"},{"location":"solvers/compact_solver.html","page":"Solving Compact Formulation","title":"Solving Compact Formulation","text":"Problem Solution\n(Image: ) (Image: )","category":"page"},{"location":"solvers/compact_solver.html","page":"Solving Compact Formulation","title":"Solving Compact Formulation","text":"Adding a demand 1 -> 7 renders the problem infeasible.","category":"page"},{"location":"solvers/compact_solver.html","page":"Solving Compact Formulation","title":"Solving Compact Formulation","text":"julia> add_demand!(pb, Demand(1, 7, 1.0))\n3-element Vector{Demand{Int64, Float64}}:\n Demand{Int64, Float64}(1, 9, 1.0)\n Demand{Int64, Float64}(1, 6, 1.0)\n Demand{Int64, Float64}(1, 7, 1.0)\n\njulia> solve_compact(pb)\nERROR: Infeasible problem\n[...]","category":"page"},{"location":"solvers/compact_solver.html#Max-acceptance","page":"Solving Compact Formulation","title":"Max-acceptance","text":"","category":"section"},{"location":"solvers/compact_solver.html","page":"Solving Compact Formulation","title":"Solving Compact Formulation","text":"We can solve the Max-acceptance variant of the problem in which a demand may not be routed and incurs a penalty M = sum(costs(pb)).","category":"page"},{"location":"solvers/compact_solver.html","page":"Solving Compact Formulation","title":"Solving Compact Formulation","text":"julia> solve_compact(pb)\nMCFSolution\n\tDemand k = 1\n\tDemand k = 2\n\t\t1.0 on VertexPath{Int64}([1, 2, 3, 6])\n\tDemand k = 3\n\t\t1.0 on VertexPath{Int64}([1, 4, 7])\n","category":"page"},{"location":"solvers/compact_solver.html","page":"Solving Compact Formulation","title":"Solving Compact Formulation","text":"Problem Solution\n(Image: ) (Image: )","category":"page"},{"location":"solvers/compact_solver.html#Index","page":"Solving Compact Formulation","title":"Index","text":"","category":"section"},{"location":"solvers/compact_solver.html","page":"Solving Compact Formulation","title":"Solving Compact Formulation","text":"Pages = [\"compact_solver.md\"]","category":"page"},{"location":"solvers/compact_solver.html#Full-docs","page":"Solving Compact Formulation","title":"Full docs","text":"","category":"section"},{"location":"solvers/compact_solver.html","page":"Solving Compact Formulation","title":"Solving Compact Formulation","text":"Modules = [MultiFlows]\nPages = [\"compact.jl\"]\n","category":"page"},{"location":"solvers/compact_solver.html#MultiFlows.add_capacity_constraints-Tuple{MCF, JuMP.Model}","page":"Solving Compact Formulation","title":"MultiFlows.add_capacity_constraints","text":"add_capacity_constraints(pb::MCF, model::JuMP.Model)\n\nAdd edge capacity constraints to the JuMP.Model.\n\n\n\n\n\n","category":"method"},{"location":"solvers/compact_solver.html#MultiFlows.add_flow_constraints","page":"Solving Compact Formulation","title":"MultiFlows.add_flow_constraints","text":"add_flow_constraints(pb::MCF, model::JuMP.Model, max_acceptance::Bool=false)\n\nAdd flow conservation constraints to the JuMP model.\n\n\n\n\n\n","category":"function"},{"location":"solvers/compact_solver.html#MultiFlows.add_objective_value","page":"Solving Compact Formulation","title":"MultiFlows.add_objective_value","text":"add_objective_value(pb::MCF, model::JuMP.Model, max_acceptance::Bool=false)\n\nAdd objective value to the JuMP.Model.\n\n\n\n\n\n","category":"function"},{"location":"solvers/compact_solver.html#MultiFlows.create_compact_model-Tuple{MCF}","page":"Solving Compact Formulation","title":"MultiFlows.create_compact_model","text":"create_compact_model(pb::MCF)\n\nCreate JuMP model corresponding to the provided MCF problem pb.\n\n\n\n\n\n","category":"method"},{"location":"solvers/compact_solver.html#MultiFlows.flow_constraint_rhs","page":"Solving Compact Formulation","title":"MultiFlows.flow_constraint_rhs","text":"flow_constraint_rhs(pb::MCF, v::Int64, k::Int64, model::JuMP.Model, max_acceptance::Bool=false)\n\nCompute the flow conservation right hand side value for vertex v and demand k.\n\n\n\n\n\n","category":"function"},{"location":"solvers/compact_solver.html#MultiFlows.solve_compact-Tuple{MCF}","page":"Solving Compact Formulation","title":"MultiFlows.solve_compact","text":"solve_compact(pb::MCF)\n\nSolve the compact formulation with state of the art solver. Returns a tuple (MCFSolution, SolverStatistics).\n\nExample\n\njulia> gr = grid((3,3));\n\njulia> pb = MCF(gr, ones(ne(gr)), ones(ne(gr)), [Demand(1,9,1.0), Demand(1,6,1.0)])\nMCF(nv = 9, ne = 24, nk = 2)\n\tDemand{Int64, Float64}(1, 9, 1.0)\n\tDemand{Int64, Float64}(1, 6, 1.0)\n\njulia> sol, ss = solve_compact(pb);\n\njulia> sol\nMCFSolution\n\tDemand k = 1\n\t\t1.0 on VertexPath{Int64}([1, 2, 5, 8, 9])\n\tDemand k = 2\n\t\t1.0 on VertexPath{Int64}([1, 4, 5, 6])\n\njulia> ss\n{\n    \"solve_time\": 0.00042557716369628906,\n    \"objective_sense\": \"MIN_SENSE\",\n    \"dual_objective_value\": 7.0,\n    \"result_count\": 1,\n    \"node_count\": -1,\n    \"objective_value\": 7.0,\n    \"objective_bound\": 0.0,\n    \"termination_status\": \"OPTIMAL\",\n    \"simplex_iterations\": 10,\n    \"barrier_iterations\": 0,\n    \"dual_status\": \"FEASIBLE_POINT\",\n    \"primal_status\": \"FEASIBLE_POINT\",\n    \"solver_name\": \"HiGHS\",\n    \"relative_gap\": null\n}\n\n\n\n\n\n\n","category":"method"},{"location":"solvers/heuristic_solver.html#Heuristics","page":"Heuristics","title":"Heuristics","text":"","category":"section"},{"location":"solvers/heuristic_solver.html","page":"Heuristics","title":"Heuristics","text":"Heuristics for solving MCF problems.","category":"page"},{"location":"solvers/heuristic_solver.html","page":"Heuristics","title":"Heuristics","text":"julia> pb = load(\"instances/toytests/test1/\", edge_dir=:single)\nMCF(nv = 7, ne = 10, nk = 3)\n\tDemand{Int64, Int64}(1, 7, 5)\n\tDemand{Int64, Int64}(2, 6, 5)\n\tDemand{Int64, Int64}(3, 7, 5)\n\njulia> solve_shortest_paths(pb)\nMCFSolution\n\tDemand k = 1\n\t\t1.0 on VertexPath{Int64}([1, 4, 6, 7])\n\tDemand k = 2\n\t\t1.0 on VertexPath{Int64}([2, 4, 6])\n\tDemand k = 3\n\t\t1.0 on VertexPath{Int64}([3, 4, 7])\n","category":"page"},{"location":"solvers/heuristic_solver.html","page":"Heuristics","title":"Heuristics","text":"By default solve_shortest_paths searches for a path for each demand, taking them in the order in wich they appear in pb.demands. The demand_permutation keyword arguments allows users to apply a different ordering scheme : ","category":"page"},{"location":"solvers/heuristic_solver.html","page":"Heuristics","title":"Heuristics","text":"julia> solve_shortest_paths(pb, demand_permutation=shuffle)\nMCFSolution\n\tDemand k = 1\n\t\t1.0 on VertexPath{Int64}([1, 4, 6, 7])\n\tDemand k = 2\n\t\t1.0 on VertexPath{Int64}([2, 4, 6])\n\tDemand k = 3\n\t\t1.0 on VertexPath{Int64}([3, 4, 7])\n","category":"page"},{"location":"solvers/heuristic_solver.html#Index","page":"Heuristics","title":"Index","text":"","category":"section"},{"location":"solvers/heuristic_solver.html","page":"Heuristics","title":"Heuristics","text":"Pages = [\"heuristic_solver.md\"]","category":"page"},{"location":"solvers/heuristic_solver.html#Full-docs","page":"Heuristics","title":"Full docs","text":"","category":"section"},{"location":"solvers/heuristic_solver.html","page":"Heuristics","title":"Heuristics","text":"Modules = [MultiFlows]\nPages = [\"heuristic.jl\"]\n","category":"page"},{"location":"solvers/heuristic_solver.html#MultiFlows.solve_shortest_paths-Union{Tuple{MCF{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Heuristics","title":"MultiFlows.solve_shortest_paths","text":"solve_shortest_paths(pb::MCF)\n\nSolve an MCF instance by taking the shortest path for each demand.\n\n\n\n\n\n","category":"method"},{"location":"solvers/column_generation.html#Column-Generation","page":"Column Generation","title":"Column Generation","text":"","category":"section"},{"location":"solvers/column_generation.html","page":"Column Generation","title":"Column Generation","text":"<img class=\"display-light-only\" src=\"../assets/img/cg_light.png\" alt=\"Column Generation\"/>\n<img class=\"display-dark-only\" src=\"../assets/img/cg_dark.png\" alt=\"Column Generation\"/>","category":"page"},{"location":"solvers/column_generation.html","page":"Column Generation","title":"Column Generation","text":"ENV[\"GKSwstype\"] = \"100\"\nENV[\"LD_LIBRARY_PATH\"] = \"\"\npush!(LOAD_PATH, \"../../..\")\nusing JuMP, Plots, MultiFlows\npb = load(\"../../../instances/toytests/test1\")\nobjvals = []\nfunction rmpcallback(rmp)\n    push!(objvals, JuMP.objective_value(rmp.model))\nend\nsolve_column_generation(pb, rmp_solve_callback=rmpcallback)\nsavefig(plot(1:size(objvals,1), objvals, xlabel=\"Iteration\", ylabel=\"Objective\"), \"callback_toytest1_cg.png\")\nnothing","category":"page"},{"location":"solvers/column_generation.html#Index","page":"Column Generation","title":"Index","text":"","category":"section"},{"location":"solvers/column_generation.html","page":"Column Generation","title":"Column Generation","text":"Pages = [\"column_generation.md\"]","category":"page"},{"location":"solvers/column_generation.html#Full-docs","page":"Column Generation","title":"Full docs","text":"","category":"section"},{"location":"solvers/column_generation.html","page":"Column Generation","title":"Column Generation","text":"Modules = [MultiFlows]\nPages = [\"column_generation.jl\"]\n","category":"page"},{"location":"solvers/column_generation.html#MultiFlows.MCFPricingProblem","page":"Column Generation","title":"MultiFlows.MCFPricingProblem","text":"MCFPricingProblem\n\nMCF Pricing problem data container.\n\n\n\n\n\n","category":"type"},{"location":"solvers/column_generation.html#MultiFlows.MCFPricingProblem-Tuple{MCF}","page":"Column Generation","title":"MultiFlows.MCFPricingProblem","text":"MCFPricingProblem\n\nPricing problem constructor for problem pb.\n\nExample\n\njulia> prp = MCFPricingProblem(pb)\nMCFPricingProblem([1, 1, 2, 4, 2, 3, 4, 6, 1, 5], [4, 2, 4, 7, 3, 4, 6, 7, 5, 7], Demand[Demand{Int64, Int64}(1, 7, 5), Demand{Int64, Int64}(2, 6, 5), Demand{Int64, Int64}(3, 7, 5)], [2.0, 3.0, 3.0, 8.0, 4.0, 8.0, 3.0, 3.0, 80.0, 20.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0])\n\n\n\n\n\n\n","category":"method"},{"location":"solvers/column_generation.html#MultiFlows.MCFRestrictedMasterProblem","page":"Column Generation","title":"MultiFlows.MCFRestrictedMasterProblem","text":"MCFRestrictedMasterProblem\n\nConcrete type representing the MCF Restricted Master Problem data.\n\n\n\n\n\n","category":"type"},{"location":"solvers/column_generation.html#MultiFlows.MCFRestrictedMasterProblem-Tuple{MCF}","page":"Column Generation","title":"MultiFlows.MCFRestrictedMasterProblem","text":"MCFRestrictedMasterProblem(pb::MCF, direct::Bool=true)\n\nInitialize the RMP for MCF problem pb. If direct=true the LP solver is used in direct mode.\n\nExample\n\njulia> pb = load(\"../instances/toytests/test1\")\nMCF(nv = 7, ne = 10, nk = 3)\n\tDemand{Int64, Int64}(1, 7, 5)\n\tDemand{Int64, Int64}(2, 6, 5)\n\tDemand{Int64, Int64}(3, 7, 5)\n\njulia> rmp = MCFRestrictedMasterProblem(pb);\n\njulia> typeof(rmp.model)\nModel (alias for GenericModel{Float64})\n\n\n\n\n\n\n","category":"method"},{"location":"solvers/column_generation.html#MultiFlows.add_column!-Union{Tuple{N}, Tuple{MCFRestrictedMasterProblem, Int64, Vector{Int64}, N, N}} where N<:Number","page":"Column Generation","title":"MultiFlows.add_column!","text":"add_column!(rmp::MCFRestrictedMasterProblem, k::Int64, column::Vector{Int64}, demand_amount::Float64, column_weight::Float64)\n\nAdd column for demand k to the master problem. column is a path p represented by a sequence of edges, a new variable x^k_p is added to the master problem, the capacity and convexity constraints are updated to take the new variable into account as well as the objective function.\n\nExample\n\njulia> num_variables(rmp.model)\n3\n\njulia> rmp.model[:capacity]\n10-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n capacity[1] : 0 ≤ 6\n capacity[2] : 0 ≤ 12\n capacity[3] : 0 ≤ 12\n capacity[4] : 0 ≤ 5\n capacity[5] : 0 ≤ 11\n capacity[6] : 0 ≤ 20\n capacity[7] : 0 ≤ 10\n capacity[8] : 0 ≤ 20\n capacity[9] : 0 ≤ 10\n capacity[10] : 0 ≤ 10\n\njulia> rmp.model[:convexity]\n3-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}, ScalarShape}}:\n convexity[1] : y1 = 1\n convexity[2] : y2 = 1\n convexity[3] : y3 = 1\n\njulia> objective_function(rmp.model)\n670 y1 + 670 y2 + 670 y3\n\n\nNow lets find a path to add to the RMP for demand k=1 and convert it to column format i.e. Vector of edge indices.\n\njulia> p = VertexPath(enumerate_paths(dijkstra_shortest_paths(pb.graph, 1), 7))\nVertexPath{Int64}([1, 4, 6, 7])\n\njulia> column = edge_indices(p, pb.graph)\n3-element Vector{Int64}:\n 1\n 7\n 8\n\njulia> pw = path_weight(p, pb.graph)\n8\n\nNow we add the column to the RMP : \n\njulia> add_column!(rmp, 1, column, pb.demands[1].amount, pw)\n\njulia> rmp.model[:capacity]\n10-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.LessThan{Float64}}, ScalarShape}}:\n capacity[1] : 5 x1[1] ≤ 6\n capacity[2] : 0 ≤ 12\n capacity[3] : 0 ≤ 12\n capacity[4] : 0 ≤ 5\n capacity[5] : 0 ≤ 11\n capacity[6] : 0 ≤ 20\n capacity[7] : 5 x1[1] ≤ 10\n capacity[8] : 5 x1[1] ≤ 20\n capacity[9] : 0 ≤ 10\n capacity[10] : 0 ≤ 10\n\njulia> rmp.model[:convexity]\n3-element Vector{ConstraintRef{Model, MathOptInterface.ConstraintIndex{MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.EqualTo{Float64}}, ScalarShape}}:\n convexity[1] : y1 + x1[1] = 1\n convexity[2] : y2 = 1\n convexity[3] : y3 = 1\n\njulia> objective_function(rmp.model)\n670 y1 + 670 y2 + 670 y3 + 40 x1[1]\n\n\n\n\n\n\n","category":"method"},{"location":"solvers/column_generation.html#MultiFlows.solution_from_rmp-Tuple{MCFRestrictedMasterProblem, MCF}","page":"Column Generation","title":"MultiFlows.solution_from_rmp","text":"solution_from_rmp(rmp::MCFRestrictedMasterProblem, pb::MCF)\n\nExtract solution to the MCF problem pb from the solution of the RMP.\n\n\n\n\n\n","category":"method"},{"location":"solvers/column_generation.html#MultiFlows.solve!-Tuple{MCFPricingProblem}","page":"Column Generation","title":"MultiFlows.solve!","text":"solve!(prp::MCFPricingProblem)\n\nSolve the pricing problem. For each demand k search for an s_k-t_k-path on the graph with reduced edge costs c_a - sigma_a where sigma_a is the dual of the capacity constraint corresponding to edge a. A path p found this way are either added to the master problem if they satisfy the negative reduced cost condition b_k * (c_p - sigma_a ) - tau_k  0.\n\nsolve!(prp) returns a list of columns which satisfy the previous condition.\n\nExample\n\njulia> prp = MCFPricingProblem(pb);\n\njulia> update_pricing_problem!(prp, sigma, tau);\n\njulia> solve!(prp)\n3-element Vector{Vector{VertexPath}}:\n [VertexPath{Int64}([1, 4, 6, 7])]\n [VertexPath{Int64}([2, 4, 6])]\n [VertexPath{Int64}([3, 4, 6, 7])]\n\n\n\n\n\n\n","category":"method"},{"location":"solvers/column_generation.html#MultiFlows.solve!-Tuple{MCFRestrictedMasterProblem}","page":"Column Generation","title":"MultiFlows.solve!","text":"solve!(rmp::MCFRestrictedMasterProblem)\n\nSolve the RMP. Calls JuMP.optimize!(rmp.model). Returns the objective value and duals for the capacity and convexity constraints.\n\nExample\n\njulia> obj, sigma, tau = solve!(rmp)\n(2010.0, [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [670.0, 670.0, 670.0])\n\n\n\n\n\n\n","category":"method"},{"location":"solvers/column_generation.html#MultiFlows.solve_column_generation-Tuple{MCF}","page":"Column Generation","title":"MultiFlows.solve_column_generation","text":"solve_column_generation(pb::MCF;\n                             max_unchanged::Int64=5,\n                             max_iterations::Int64=100,\n                             direct::Bool=true,\n                             return_rmp::Bool=false,\n)\n\nSolve MCF problem using Column Generation. Returns a MCFSolution object and  a SolverStatistics containing statistics from the solver run. If return_rmp=true the second return value is a tuple where the first item is the JuMP.Model corresponding to the final RMP and the second item are the solver statistics.\n\nArgument Description\nmax_unchanged Maximum number of successive iterations without improvement of the objective function\nmax_iterations Maximum number of CG iterations\ndirect Use direct solver\nrmpsolvecallback Function called after each resolution of the RMP\n\nExample\n\njulia> sol, (rmp, ss) = solve_column_generation(pb);\n\njulia> value.(all_variables(rmp.model))\n9-element Vector{Float64}:\n  0.0\n  0.0\n  0.0\n  0.0\n  1.0\n  1.0\n  1.0\n -0.0\n -0.0\n\njulia> ss.stats[\"objective_value\"]\n150.0\n\n\nYou may supply a callback function with the rmp_solve_callback. The supplied function must accept a single MCFRestrictedMasterProblem argument and will be executed rmp_solve_callback(rmp) at each iteration before calling solve! on the pricing problem.\n\njulia> using Plots\n\njulia> pb = load(\"../instances/toytests/test1\");\n\njulia> objvals = []\nAny[]\n\njulia> function rmpcallback(rmp)\n           push!(objvals, JuMP.objective_value(rmp.model))\n       end\n\njulia> solve_column_generation(pb, rmp_solve_callback=rmpcallback);\n\njulia> savefig(plot(1:size(objvals,1), objvals, xlabel=\"Time\", ylabel=\"Objective\"), \"callback_toytest1_cg.png\");\n\n\n(Image: )\n\n\n\n\n\n","category":"method"},{"location":"solvers/column_generation.html#MultiFlows.update_pricing_problem!-Tuple{MCFPricingProblem, Any, Any}","page":"Column Generation","title":"MultiFlows.update_pricing_problem!","text":"update_pricing_problem!(prp::MCFPricingProblme, capacity_duals::Vector{Float64}, convexity_duals::Vector{Float64}\n\nUpdate the pricing problem data. Sets the values of the capacity and convexity constraint duals to the latest values given by solving the RMP.\n\n\n\n\n\n","category":"method"},{"location":"datasets/generators.html#Instance-generation","page":"Instance generation","title":"Instance generation","text":"","category":"section"},{"location":"datasets/generators.html","page":"Instance generation","title":"Instance generation","text":"Functions and routines for creating new instances by applying perturbations to a reference problem. These functions are used for creating training and testing sets for training Sparsifying models.","category":"page"},{"location":"datasets/generators.html","page":"Instance generation","title":"Instance generation","text":"ENV[\"GKSwstype\"] = \"100\"\npush!(LOAD_PATH, \"../../..\")\nusing Graphs, Random, Compose, MultiFlows, GraphPlot, Colors\nRandom.seed!(123)\ngr = grid((3,3))\nloc_x, loc_y = spring_layout(gr)\npb = MCF(gr, ones(12), ones(12), [Demand(1,8,1.),Demand(7,5,.5)])\npb1 = shake(pb)\npb2 = shake(pb, origins_destinations=(1:nv(pb), 1:nv(pb)))\ndraw(PNG(\"origin_grid_mcf.png\",16cm,16cm), mcfplot(pb, loc_x, loc_y))\ndraw(PNG(\"shook_grid_mcf_1.png\",16cm,16cm), mcfplot(pb1, loc_x, loc_y))\ndraw(PNG(\"shook_grid_mcf_2.png\",16cm,16cm), mcfplot(pb2, loc_x, loc_y))\n\n# saturating instance\nRandom.seed!(123)\nloc_x1, loc_y1 = spring_layout(gr)\npb = MCF(gr, ones(12), ones(12), [Demand(1,2,.5)])\npb = shake(pb, nK=5, origins_destinations=(1:nv(pb),1:nv(pb)))\nsol,_ = solve_column_generation(pb)\ndraw(PNG(\"grid3x3_nonsat_solution.png\", 16cm, 16cm), mcfsolplot(sol, pb, loc_x, loc_y, minedgelinewidth=1, maxedgelinewidth=1))\navail = available_capacity(sol, pb)\notherdir = vcat(avail[Int64(ne(pb)/2)+1:end], avail[1:Int64(ne(pb)/2)])\nH = vec(minimum(hcat(avail, otherdir), dims=2))\ncom = range(HSL(colorant\"red\"), stop=HSL(colorant\"green\"), length=100)\nedgestrokec = com[trunc.(Int64, H * 99) .+ 1]\ndraw(PNG(\"grid3x3_nonsat_capacities.png\", 16cm, 16cm), gplot(pb.graph, loc_x, loc_y, edgestrokec=edgestrokec, arrowlengthfrac=0, nodelabel=collect(1:nv(pb))))\npb_sat,sol_sat = MultiFlows.saturate(pb)\navail = available_capacity(sol_sat, pb_sat)\notherdir = vcat(avail[Int64(ne(pb_sat)/2)+1:end], avail[1:Int64(ne(pb_sat)/2)])\nH = vec(minimum(hcat(avail, otherdir), dims=2))\nedgestrokec = com[trunc.(Int64, H * 99) .+ 1]\ndraw(PNG(\"grid3x3_sat_capacities.png\", 16cm, 16cm), gplot(pb_sat.graph, loc_x, loc_y, edgestrokec=edgestrokec, arrowlengthfrac=0, nodelabel=collect(1:nv(pb))))\nnothing","category":"page"},{"location":"datasets/generators.html#Index","page":"Instance generation","title":"Index","text":"","category":"section"},{"location":"datasets/generators.html","page":"Instance generation","title":"Instance generation","text":"Pages = [\"generators.md\"]","category":"page"},{"location":"datasets/generators.html#Full-docs","page":"Instance generation","title":"Full docs","text":"","category":"section"},{"location":"datasets/generators.html","page":"Instance generation","title":"Instance generation","text":"Modules = [MultiFlows]\nPages = [\"generators.jl\"]\n","category":"page"},{"location":"datasets/generators.html#MultiFlows.generate_example-Tuple{MCF}","page":"Instance generation","title":"MultiFlows.generate_example","text":"generate_example(pb::MCF; \n                 demand_p::Float64=.05, \n                 amount_factor::Float64=1.05,\n                 nK::Int64=nk(pb),\n                 sample_f::Function=Base.rand,\n                 solve_f::Function=solve_column_generation,\n                 demand_order_f::Function=identity,\n                 amount_delta_f::Function=identity\n\n)\n\nGenerate an example based on instance pb. Returns an instance that is the results of applying shake, saturate and then increasing the amount of a randomly chosen set of demands by multiplying its amount by amout_factor.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(7), ones(7), [Demand(1,2,1.)]);\n\njulia> generate_example(pb)\nMCF(nv = 6, ne = 14, nk = 1)\n\tDemand{Int64, Float64}(1, 2, 1.05)\n\njulia> # change the number of demands\n\njulia> generate_example(pb, nK=10)\nMCF(nv = 6, ne = 14, nk = 10)\n\tDemand{Int64, Float64}(1, 2, 1.0)\n\tDemand{Int64, Float64}(1, 2, 1.05)\n\tDemand{Int64, Float64}(1, 2, 1.0)\n\tDemand{Int64, Float64}(1, 2, 1.0)\n\tDemand{Int64, Float64}(1, 2, 1.0)\n\tDemand{Int64, Float64}(1, 2, 1.0)\n\tDemand{Int64, Float64}(1, 2, 1.0)\n\tDemand{Int64, Float64}(1, 2, 1.0)\n\tDemand{Int64, Float64}(1, 2, 1.0)\n\tDemand{Int64, Float64}(1, 2, 1.0)\n\n\n\n\n\n\n","category":"method"},{"location":"datasets/generators.html#MultiFlows.make_dataset-Tuple{MCF, Int64, String}","page":"Instance generation","title":"MultiFlows.make_dataset","text":"make_dataset(pb::MCF, n::Int64, path::String)\n\nCreate a dataset by applying perturbations to a reference instance. Saves resulting instance and solution files to path directory.\n\n\n\n\n\n","category":"method"},{"location":"datasets/generators.html#MultiFlows.non_saturated_path_exists-Tuple{MCFSolution, MCF}","page":"Instance generation","title":"MultiFlows.non_saturated_path_exists","text":"non_saturated_path_exists(sol::MCFSolution, pb::MCF; tol::Float64=1e-8)\n\nCheck if the solution contains a path with capacity greater than the amount of flow circulating on it.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(7), ones(7), [Demand(1,2,1.)]);\n\njulia> sol,_ = solve_column_generation(pb);\n\njulia> sol\nMCFSolution\n\tDemand k = 1\n\t\t1.0 on VertexPath{Int64}([1, 2])\n\njulia> non_saturated_path_exists(sol, pb)\nfalse\n\njulia> sol.flows[1][1] = .5\n0.5\n\njulia> non_saturated_path_exists(sol, pb)\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"datasets/generators.html#MultiFlows.random_demand_amounts-Union{Tuple{MCF}, Tuple{N}, Tuple{MCF, Int64}} where N<:Number","page":"Instance generation","title":"MultiFlows.random_demand_amounts","text":"random_demand_bandwidths(pb::MCF, n::Int64=nk(pb); factor::Float64=1.)\n\nSelect n demand amounts randomly by sampling values from  b_k _kin K.\n\nExample\n\njulia> unique(demand_amounts(pb))\n4-element Vector{Float64}:\n  500.0\n   50.0\n 1000.0\n  100.0\n\njulia> new_amounts = random_demand_amounts(pb, 100);\n\njulia> unique(new_amounts)\n4-element Vector{Float64}:\n  500.0\n 1000.0\n  100.0\n   50.0\n\n\nThe factor arguments lets one apply a scaling to the amounts : \n\njulia> new_amounts = random_demand_amounts(pb, 100, factor=2.0);\n\njulia> unique(new_amounts)\n4-element Vector{Float64}:\n 2000.0\n  100.0\n  200.0\n 1000.0\n\n\n\n\n\n\n","category":"method"},{"location":"datasets/generators.html#MultiFlows.random_demand_endpoints-Union{Tuple{MCF{T, N}}, Tuple{N}, Tuple{T}, Tuple{MCF{T, N}, Int64}} where {T, N}","page":"Instance generation","title":"MultiFlows.random_demand_endpoints","text":"random_demand_endpoints(pb::MCF{T,N}, n::Int64=nk(pb);\n                             origins_destinations::Tuple{Vector{Int64}, Vector{Int64}}=demand_endpoints(pb),\n                             sample_f::Function=Base.rand,\n) where {T,N}\n\nSample new demand endpoints s_k t_k randomly from  s_k t_k _kin K. The set of origins and destinations from which new endpoints are sampled can be changed by passing a value to the origins_destinations arguments. Similarly sample_f is a sampling function, the default value samples new endpoints uniformly at random.\n\nExample\n\njulia> random_demand_endpoints(pb, 5)\n([29, 57, 21, 47, 64], [20, 9, 63, 54, 57])\n\njulia> random_demand_endpoints(pb, 5, origins_destinations=(1:nv(pb), 1:nv(pb)))\n([35, 55, 3, 31, 24], [7, 47, 38, 44, 20])\n\n\n\n\n\n\n","category":"method"},{"location":"datasets/generators.html#MultiFlows.saturate-Union{Tuple{MCF{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Instance generation","title":"MultiFlows.saturate","text":"saturate(pb::MCF{T,N}; \n         tol::Float64=1e-8, \n         max_iter::Int64=10, \n         solve_f::Function=solve_column_generation,\n         demand_order_f::Function=identity,\n         amount_delta_f::Function=identity\n) where {T,N}\n\nSaturate an MCF instance. Increase the amount of each demand until reaching the maximum capacity of the paths used to route them. pb is solved by calls to solve_f until the returned solution does not contain a path with zero minimum available capacity. The maximum number of times the solver is called is max_iter. Default behaviour is to take the demands in their original order and increase the amount by minlimits_a in p_k textavailable_capacity(a), changing the demand_order_f, amount_delta_f functions lets users modify this scheme. Setting demand_order_f=shuffle will randomize the order in which the demands are increased, and amount_delta_f=ak->rand()*ak will increase the amount of demand k by a random number sampled from mathcalU(0 a_k) where a_k is the available capacity on the path.\n\nThis function return a Tuple{MCF, MCFSolution} object.\n\njulia> pb\nMCF(nv = 9, ne = 24, nk = 5)\n\tDemand{Int64, Float64}(9, 5, 0.5)\n\tDemand{Int64, Float64}(8, 1, 0.5)\n\tDemand{Int64, Float64}(8, 6, 0.5)\n\tDemand{Int64, Float64}(8, 7, 0.5)\n\tDemand{Int64, Float64}(6, 9, 0.5)\n\njulia> pb_sat, sol_sat = saturate(pb);\n\njulia> pb_sat\nMCF(nv = 9, ne = 24, nk = 5)\n\tDemand{Int64, Float64}(9, 5, 1.0)\n\tDemand{Int64, Float64}(8, 1, 0.5)\n\tDemand{Int64, Float64}(8, 6, 1.0)\n\tDemand{Int64, Float64}(8, 7, 0.5)\n\tDemand{Int64, Float64}(6, 9, 1.0)\n\nsol sol available capacities sol_sat available capacities\n(Image: ) (Image: ) (Image: )\n\njulia> sol,_ = solve_column_generation(pb);\n\njulia> sol_sat,_ = solve_column_generation(pb_sat);\n\njulia> non_saturated_path_exists(sol, pb)\ntrue\n\njulia> non_saturated_path_exists(sol_sat, pb_sat)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"datasets/generators.html#MultiFlows.shake-Union{Tuple{MCF{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Instance generation","title":"MultiFlows.shake","text":"shake_instance(pb::MCF{T,N}; \n               nK::Int64=nk(pb),\n               amount_factor::Float64=1., \n               origins_destinations::Tuple{AbstractVector{T}, AbstractVector{T}}=demand_endpoints(pb),\n               sample_f::Function=Base.rand,\n              ) where {T,N}\n\nApply demand amount and endpoint perturbation to an MCF instance.\n\nExample\n\njulia> pb = MCF(grid((3,3)), ones(12), ones(12), [Demand(1,8,1.), Demand(7,5,.5)]);\n\njulia> shake(pb)\nMCF(nv = 9, ne = 24, nk = 2)\n\tDemand{Int64, Float64}(7, 8, 0.5)\n\tDemand{Int64, Float64}(7, 5, 0.5)\n\njulia> shake(pb, origins_destinations=(1:nv(pb),1:nv(pb)))\nMCF(nv = 9, ne = 24, nk = 2)\n\tDemand{Int64, Float64}(8, 5, 0.5)\n\tDemand{Int64, Float64}(6, 1, 0.5)\n\n\npb pb1 pb2\n(Image: ) (Image: ) (Image: )\n\n\n\n\n\n","category":"method"},{"location":"mcf/plot.html#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"mcf/plot.html","page":"Plotting","title":"Plotting","text":"Plotting MCF problems is done by using the GraphPlot.jl package. A plot can be generated through use of the mcfplot(pb::MCF, layout::Function=spring_layout) function. ","category":"page"},{"location":"mcf/plot.html#Instances","page":"Plotting","title":"Instances","text":"","category":"section"},{"location":"mcf/plot.html","page":"Plotting","title":"Plotting","text":"julia> pb = load(\"instances/toytests/test1/\", edge_dir=:single)\nMCF(nv = 7, ne = 10, nk = 3)\n\tDemand{Int64, Int64}(1, 7, 5)\n\tDemand{Int64, Int64}(2, 6, 5)\n\tDemand{Int64, Int64}(3, 7, 5)\n\njulia> # draw and save figure\n\njulia> draw(PNG(\"test1.png\", 16cm, 16cm), mcfplot(pb))","category":"page"},{"location":"mcf/plot.html","page":"Plotting","title":"Plotting","text":"(Image: toytesttest1)","category":"page"},{"location":"mcf/plot.html#Solution","page":"Plotting","title":"Solution","text":"","category":"section"},{"location":"mcf/plot.html","page":"Plotting","title":"Plotting","text":"It is possible to use MultiFlows.graph_with_demand_edges(pb::MCF) to create a directed graph with edges added between demand endpoints. This can be usefull when generating layout locations and drawing consistent problem and solution plots.","category":"page"},{"location":"mcf/plot.html","page":"Plotting","title":"Plotting","text":"julia> using GraphPlot\n\njulia> g = MultiFlows.graph_with_demand_edges(pb)\n{7, 23} directed simple Int64 graph\n\njulia> loc_x, loc_y = spring_layout(g);","category":"page"},{"location":"mcf/plot.html","page":"Plotting","title":"Plotting","text":"We can now plot the graph with solution edges outlined : ","category":"page"},{"location":"mcf/plot.html","page":"Plotting","title":"Plotting","text":"julia> draw(PNG(\"test1_solution.png\", 16cm, 16cm), mcfsolplot(sol, pb, loc_x, loc_y))","category":"page"},{"location":"mcf/plot.html","page":"Plotting","title":"Plotting","text":"(Image: toytesttest1sol)","category":"page"},{"location":"mcf/plot.html","page":"Plotting","title":"Plotting","text":"Note that mcfsolplot can also be called without the loc_x,loc_y arguments : mcfsolplot(sol, pb). ","category":"page"},{"location":"mcf/plot.html#Index","page":"Plotting","title":"Index","text":"","category":"section"},{"location":"mcf/plot.html","page":"Plotting","title":"Plotting","text":"Pages = [\"plot.md\"]","category":"page"},{"location":"mcf/plot.html#Full-docs","page":"Plotting","title":"Full docs","text":"","category":"section"},{"location":"mcf/plot.html","page":"Plotting","title":"Plotting","text":"Modules = [MultiFlows]\nPages = [\"plot.jl\"]\n","category":"page"},{"location":"mcf/plot.html#MultiFlows.mcfplot","page":"Plotting","title":"MultiFlows.mcfplot","text":"mcfplot(pb::MCF, layout::Function=spring_layout;\n        minedgelinewidth=1.0,\n        maxedgelinewidth=10.0,\n)\n\nPlot MCF problem. MultiFlows.jl uses the GraphPlot.jl package for generating graph plots. Edge line widths are scaled onto [minedgelinewidth, maxedgelinewidth] as a function of edge capacity and demand amounts.\n\n\n\n\n\n","category":"function"},{"location":"mcf/plot.html#MultiFlows.mcfplot-Tuple{MCF, Vector{Float64}, Vector{Float64}}","page":"Plotting","title":"MultiFlows.mcfplot","text":"mcfplot(pb::MCF, loc_x::Vector{Float64}, loc_y::Vector{Float64};\n        minedgelinewidth=1.0,\n        maxedgelinewidth=10.0,\n)\n\nPlot MCF problem. MultiFlows.jl uses the GraphPlot.jl package for generating graph plots. Edge line widths are scaled onto [minedgelinewidth, maxedgelinewidth] as a function of edge capacity and demand amounts.\n\n\n\n\n\n","category":"method"},{"location":"mcf/plot.html#MultiFlows.mcfsolplot","page":"Plotting","title":"MultiFlows.mcfsolplot","text":"mcfsolplot(sol::MCFSolution, pb::MCF, layout::Function=spring_layout;\n        minedgelinewidth=1.0,\n        maxedgelinewidth=10.0,\n)\n\nPlot MCF solution.\n\n\n\n\n\n","category":"function"},{"location":"mcf/plot.html#MultiFlows.mcfsolplot-Tuple{MCFSolution, MCF, Vector{Float64}, Vector{Float64}}","page":"Plotting","title":"MultiFlows.mcfsolplot","text":"mcfsolplot(sol::MCFSolution, pb::MCF, loc_x::Vector{R1}, loc_y::Vector{R2};\n        minedgelinewidth=1.0,\n        maxedgelinewidth=10.0,\n)\n\nPlot MCF solution.\n\n\n\n\n\n","category":"method"},{"location":"index.html#MultiFlows.jl","page":"MultiFlows.jl","title":"MultiFlows.jl","text":"","category":"section"},{"location":"index.html","page":"MultiFlows.jl","title":"MultiFlows.jl","text":"(Image: Documentation) (Image: Documentation)","category":"page"},{"location":"index.html#Overview","page":"MultiFlows.jl","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"MultiFlows.jl","title":"MultiFlows.jl","text":"MultiFlows.jl is a Julia package for solving Multi-Commodity Flow problems. The package implements a collection of solver methods : ","category":"page"},{"location":"index.html","page":"MultiFlows.jl","title":"MultiFlows.jl","text":"direct solver implementation (using JuMP.jl)\ncolumn generation frameworks\nmachine learning based solvers","category":"page"},{"location":"index.html#Basic-usage","page":"MultiFlows.jl","title":"Basic usage","text":"","category":"section"},{"location":"index.html","page":"MultiFlows.jl","title":"MultiFlows.jl","text":"Load an Multi-Commodity Flow instance from a directory dirname. The directory should contain two files : a link.csv file containing graph edge data and a service.csv file containing demand data.","category":"page"},{"location":"index.html","page":"MultiFlows.jl","title":"MultiFlows.jl","text":"julia> using MultiFlows\n\njulia> pb = load(dirname)\nMCF(nv = 7, ne = 10, nk = 3)\n\tDemand{Int64, Int64}(1, 7, 5)\n\tDemand{Int64, Int64}(2, 6, 5)\n\tDemand{Int64, Int64}(3, 7, 5)\n","category":"page"},{"location":"index.html","page":"MultiFlows.jl","title":"MultiFlows.jl","text":"This package offers a collection of solvers for these problems.","category":"page"},{"location":"index.html","page":"MultiFlows.jl","title":"MultiFlows.jl","text":"julia> sol, ss = solve_compact(pb); # solve compact formulation\n\njulia> sol, ss = solve_column_generation(pb) # solve by column generation\n\njulia> sol","category":"page"},{"location":"index.html#Documentation","page":"MultiFlows.jl","title":"Documentation","text":"","category":"section"},{"location":"index.html","page":"MultiFlows.jl","title":"MultiFlows.jl","text":"The full documentation is available at GitHub Pages. ","category":"page"}]
}
