var documenterSearchIndex = {"docs":
[{"location":"core_functions/feature_graph.html#Feature-Graph","page":"Feature Graph","title":"Feature Graph","text":"","category":"section"},{"location":"core_functions/feature_graph.html","page":"Feature Graph","title":"Feature Graph","text":"Definition of the FeatureDiGraph object used for representing directed graphs with multi-dimensional features on edges.","category":"page"},{"location":"core_functions/feature_graph.html#Index","page":"Feature Graph","title":"Index","text":"","category":"section"},{"location":"core_functions/feature_graph.html","page":"Feature Graph","title":"Feature Graph","text":"Pages = [\"feature_graph.md\"]","category":"page"},{"location":"core_functions/feature_graph.html#Full-docs","page":"Feature Graph","title":"Full docs","text":"","category":"section"},{"location":"core_functions/feature_graph.html","page":"Feature Graph","title":"Feature Graph","text":"Modules = [MultiFlows]\nPages = [\"feature_graph.jl\"]\n","category":"page"},{"location":"core_functions/feature_graph.html#MultiFlows.FeatureDiGraph","page":"Feature Graph","title":"MultiFlows.FeatureDiGraph","text":"FeatureDiGraph{T,N}\n\nConcrete directed graph with a feature vector for each edge.\n\nThe default constructor expects srcnodes, dstnodes to be vectors of source and destination vertices for each edge and features to by a vector of numbers. The following example initialises a directed graph with three vertices and edges and a single Float64 feature on each edge.\n\nExamplex\n\njulia> using MultiFlows\n\njulia> g1 = FeatureDiGraph([1,2,3], [2,3,1], [5., 5., 5.])\nFeatureDiGraph{Int64, Float64}([1, 2, 3], [2, 3, 1], [5.0, 5.0, 5.0])\n\n\n\n\n\n\n","category":"type"},{"location":"core_functions/feature_graph.html#MultiFlows.FeatureDiGraph-Union{Tuple{N}, Tuple{T}, Tuple{Graphs.AbstractGraph{T}, AbstractArray{N}}} where {T<:Number, N<:Number}","page":"Feature Graph","title":"MultiFlows.FeatureDiGraph","text":"FeatureDiGraph(g::AbstractGraph{T}, features::AbstractArray{N})\n\nConstruct a feature graph from an AbstractGraph object and a set of features. If g is an undirected graph the edges will be added in both directions and features should have first dimension either ne(g) in which case features are duplicated in both directions, or 2*ne(g).\n\nExamples\n\njulia> using Graphs\n\njulia> gr = complete_digraph(5)\n{5, 20} directed simple Int64 graph\n\njulia> FeatureDiGraph(gr, ones(ne(gr), 2))\nFeatureDiGraph{Int64, Vector{Float64}}([1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5], [2, 3, 4, 5, 1, 3, 4, 5, 1, 2, 4, 5, 1, 2, 3, 5, 1, 2, 3, 4], [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0]])\n\njulia> gr = complete_graph(5)\n{5, 10} undirected simple Int64 graph\n\njulia> FeatureDiGraph(gr, ones(2*ne(gr), 2))\nFeatureDiGraph{Int64, Vector{Float64}}([1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 2, 3, 4, 5, 3, 4, 5, 4, 5, 5], [2, 3, 4, 5, 3, 4, 5, 4, 5, 5, 1, 1, 1, 1, 2, 2, 2, 3, 3, 4], [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0]])\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.FeatureDiGraph-Union{Tuple{N}, Tuple{T}, Tuple{Vector{T}, Vector{T}, AbstractArray{N}}} where {T<:Number, N<:Number}","page":"Feature Graph","title":"MultiFlows.FeatureDiGraph","text":"FeatureDiGraph(srcnodes::Vector{T}, dstnodes::Vector{T}, features::AbstractArray{N}) where {T<:Number, N<:Number}\n\nConstruct a FeatureDiGraph object where edge features are given by features[i,:].\n\nExamplex\n\nFor example we can build a graph with a two-dimensional feature on each edge : \n\njulia> g = FeatureDiGraph([1,2,3], [2,3,1], 5 * ones(3,2))\nFeatureDiGraph{Int64, Vector{Float64}}([1, 2, 3], [2, 3, 1], [[5.0, 5.0], [5.0, 5.0], [5.0, 5.0]])\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.FeatureDiGraphEdge","page":"Feature Graph","title":"MultiFlows.FeatureDiGraphEdge","text":"FeatureDiGraphEdge\n\nConcrete type representing FeatureDiGraph edges.\n\n\n\n\n\n","category":"type"},{"location":"core_functions/feature_graph.html#Base.reverse-Tuple{FeatureDiGraphEdge}","page":"Feature Graph","title":"Base.reverse","text":"\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.SimpleGraphs.add_edge!-Union{Tuple{N}, Tuple{T}, Tuple{FeatureDiGraph{T, N}, T, T, N}} where {T<:Number, N}","page":"Feature Graph","title":"Graphs.SimpleGraphs.add_edge!","text":"Graphs.add_edge!(g::FeatureDiGraph{T,N}, src::T, dst::T, feat::N}\n\nAdd edge to a FeatureDiGraph object going from vertex src to dst and with features feat. Return true on success and false if graph already has an edge (src, dst). \n\nExamples\n\njulia> g = FeatureDiGraph([1,2,3], [2,3,1], ones(3,2));\n\njulia> add_edge!(g, 1, 4, [2., 2.])\ntrue\n\njulia> add_edge!(g, 1, 2, [3., 3.])\nfalse\n\njulia> nv(g), ne(g)\n(4, 4)\n\njulia> add_edge!(g, 1, 4, ones(3)) # must have feature_dim(g) == size(feat)\nERROR: DimensionMismatch(\"Expected feature dimension (2,) got (3,)\")\n[...]\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.dst-Tuple{FeatureDiGraphEdge}","page":"Feature Graph","title":"Graphs.dst","text":"Graphs.dst(e::FeatureDiGraphEdge)\n\nGet edge destination.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.edges-Tuple{FeatureDiGraph}","page":"Feature Graph","title":"Graphs.edges","text":"edges(g::FeatureDiGraph)\n\nReturn list of edges of the graph. Needed for compatibility with Graphs.jl package.\n\nExamples\n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,4], [1,1,1,2]);\n\njulia> edges(g)\n4-element Vector{FeatureDiGraphEdge{Int64, Int64}}:\n FeatureDiGraphEdge{Int64, Int64}(1, 2, 1)\n FeatureDiGraphEdge{Int64, Int64}(2, 3, 1)\n FeatureDiGraphEdge{Int64, Int64}(3, 1, 1)\n FeatureDiGraphEdge{Int64, Int64}(1, 4, 2)\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.has_edge-Union{Tuple{N}, Tuple{T}, Tuple{FeatureDiGraph{T, N}, T, T}} where {T<:Number, N}","page":"Feature Graph","title":"Graphs.has_edge","text":"Graphs.has_edge(g::FeatureDiGraph{T,N}, s::T, d::T)\n\nCheck if graph contains edge (s,d). \n\nExamples\n\njulia> using Graphs\n\njulia> has_edge(g, 1, 2)\ntrue\n\njulia> has_edge(g, 2, 1)\nfalse\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.inneighbors-Union{Tuple{N}, Tuple{T}, Tuple{FeatureDiGraph{T, N}, T}} where {T<:Number, N}","page":"Feature Graph","title":"Graphs.inneighbors","text":"Graphs.inneighbors(g::FeatureDiGraph{T,N}, v::T)\n\nGet neighbors u of vertex v such that edge (u,v) belongs to the graph. Needed for compatibility with Graphs.jl package.\n\nExamples\n\njulia> inneighbors(g, 1)\n1-element Vector{Int64}:\n 3\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.is_directed-Tuple{FeatureDiGraph}","page":"Feature Graph","title":"Graphs.is_directed","text":"Graphs.is_directed(g::FeatureDiGraph{T,N})\n\nCheck if the graph is directed, always returns true. Needed for compatibility with the Graphs.jl package.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.ne-Tuple{FeatureDiGraph}","page":"Feature Graph","title":"Graphs.ne","text":"ne(g::FeatureDiGraph)\n\nReturn number of edge of the graph. Needed for compatibility with the Graphs.jl package.\n\nExamples\n\njulia> ne(g)\n3\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.nv-Tuple{FeatureDiGraph}","page":"Feature Graph","title":"Graphs.nv","text":"nv(g::FeatureDiGraph)\n\nReturns number of vertices of the graph. Needed for compatibility with the Graphs.jl package.\n\nExamples\n\njulia> nv(g)\n3\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.outneighbors-Union{Tuple{N}, Tuple{T}, Tuple{FeatureDiGraph{T, N}, T}} where {T<:Number, N}","page":"Feature Graph","title":"Graphs.outneighbors","text":"Graphs.outneighbors(g::FeatureDiGraph{T,N}, v::T)\n\nGet outgoing neighbors of vertex v in the graph. Needed for compatibility with Graphs.jl package.\n\nExamples\n\njulia> outneighbors(g, 1)\n2-element Vector{Int64}:\n 2\n 4\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.src-Tuple{FeatureDiGraphEdge}","page":"Feature Graph","title":"Graphs.src","text":"Graphs.src(e::FeatureDiGraphEdge)\n\nGet edge source.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#Graphs.weights","page":"Feature Graph","title":"Graphs.weights","text":"Graphs.weights(g::FeatureDiGraph, feature_idx::Int64=1)\n\nGet graph weight matrix corresponding to in feature with index idx. Needed for compatibility with Graphs.jl.\n\nExamples\n\njulia> using Graphs\n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,3],[[1,1],[1,1],[1,1],[4,1]])\nFeatureDiGraph{Int64, Vector{Int64}}([1, 2, 3, 1], [2, 3, 1, 3], [[1, 1], [1, 1], [1, 1], [4, 1]])\n\njulia> ds = dijkstra_shortest_paths(g, 1);\n\njulia> enumerate_paths(ds, 3)\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> ds = dijkstra_shortest_paths(g, 1, weights(g, 2));\n\njulia> enumerate_paths(ds, 3)\n2-element Vector{Int64}:\n 1\n 3\n\n\n\n\n\n","category":"function"},{"location":"core_functions/feature_graph.html#MultiFlows.double_edges!-Tuple{FeatureDiGraph}","page":"Feature Graph","title":"MultiFlows.double_edges!","text":"double_edges!(g::FeatureDiGraph)\n\nFor each edge (u,v) add edge (v,u) if not already present in the graph. Features of the edge are copied.\n\nExamples\n\njulia> using Graphs\n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,3],[[1,1],[1,1],[1,1],[4,1]])\nFeatureDiGraph{Int64, Vector{Int64}}([1, 2, 3, 1], [2, 3, 1, 3], [[1, 1], [1, 1], [1, 1], [4, 1]])\n\njulia> ne(g)\n4\n\njulia> double_edges!(g)\nFeatureDiGraph{Int64, Vector{Int64}}([1, 2, 3, 1, 2, 3], [2, 3, 1, 3, 1, 2], [[1, 1], [1, 1], [1, 1], [4, 1], [1, 1], [1, 1]])\n\njulia> ne(g)\n6\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.edge_features-Tuple{FeatureDiGraph, Int64}","page":"Feature Graph","title":"MultiFlows.edge_features","text":"edge_features(g::FeatureDiGraph, idx::Int64)\n\nGet array of edge features corresponding to index idx. Returns a (ne(g), 1) array.\n\nExamples\n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,4], hcat(3*ones(4), 4*ones(4)));\n\njulia> edge_features(g, 1)\n4-element Vector{Float64}:\n 3.0\n 3.0\n 3.0\n 3.0\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.edge_features-Tuple{FeatureDiGraph}","page":"Feature Graph","title":"MultiFlows.edge_features","text":"edge_features(g::FeatureDiGraph)\n\nGet array of edge features. Returns a (ne(g), feature_dim(g)) array.\n\nExamples\n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,4], hcat(3*ones(4), 4*ones(4)));\n\njulia> edge_features(g)\n4×2 Matrix{Float64}:\n 3.0  4.0\n 3.0  4.0\n 3.0  4.0\n 3.0  4.0\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.edge_index_matrix-Union{Tuple{Graphs.AbstractGraph{T}}, Tuple{T}} where T","page":"Feature Graph","title":"MultiFlows.edge_index_matrix","text":"edge_index_matrix(g::AbstractGraph)\n\nGet (nv(g), nv(g)) sized matrix where M[i,j] is the index of edge i,j.\n\nExamples\n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,4], hcat(3*ones(4), 4*ones(4)));\n\njulia> edge_index_matrix(g)\n3×4 SparseArrays.SparseMatrixCSC{Int64, Int64} with 4 stored entries:\n ⋅  1  ⋅  4\n ⋅  ⋅  2  ⋅\n 3  ⋅  ⋅  ⋅\n\nSimple undirected graphs : \n\njulia> using Graphs\n\njulia> g = grid((3,2))\n{6, 7} undirected simple Int64 graph\n\njulia> edge_index_matrix(g)\n6×6 SparseArrays.SparseMatrixCSC{Int64, Int64} with 14 stored entries:\n ⋅  1  ⋅  2  ⋅  ⋅\n 1  ⋅  3  ⋅  4  ⋅\n ⋅  3  ⋅  ⋅  ⋅  5\n 2  ⋅  ⋅  ⋅  6  ⋅\n ⋅  4  ⋅  6  ⋅  7\n ⋅  ⋅  5  ⋅  7  ⋅\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.feature_dim-Tuple{FeatureDiGraph}","page":"Feature Graph","title":"MultiFlows.feature_dim","text":"feature_dim(g::FeatureDiGraph)\n\nGet edge feature dimension. \n\nExamplex\n\njulia> g1 = FeatureDiGraph([1,2,3], [2,3,1], ones(3));\n\njulia> feature_dim(g1) # scalar features\n()\n\njulia> g2 = FeatureDiGraph([1,2,3], [2,3,1], ones(3, 2));\n\njulia> feature_dim(g2)  # two-dimension features\n(2,)\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.feature_matrix-Tuple{FeatureDiGraph, AbstractArray{Int64}}","page":"Feature Graph","title":"MultiFlows.feature_matrix","text":"feature_matrix(g::FeatureDiGraph, feature_idx::AbstractArray{Int64})\n\nGet a nv(g) x nv(g) x size(feature_idx) matrix with coefficients equal to edge feature values corresponding to indexes in feature_idx. TODO : managing feature_idx with multiple dimensions.\n\nExamples\n\njulia> feature_matrix(g, [2, 1])\n4×4×2 Array{Float64, 3}:\n[:, :, 1] =\n 0.0  4.0  0.0  4.0\n 0.0  0.0  4.0  0.0\n 4.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n\n[:, :, 2] =\n 0.0  3.0  0.0  3.0\n 0.0  0.0  3.0  0.0\n 3.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.feature_matrix-Union{Tuple{FeatureDiGraph}, Tuple{N}, Tuple{T}, Tuple{FeatureDiGraph, Int64}} where {T<:Number, N}","page":"Feature Graph","title":"MultiFlows.feature_matrix","text":"feature_matrix(g::FeatureDiGraph, feature_idx::Int64)\n\nGet a nv(g) x nv(g) matrix with coefficients equal to edge feature values. Values returned as a sparse matrix.\n\nExamples\n\nGraph with scalar features : \n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,4], [5.0, 5.0, 5.0, 1.0]);\n\njulia> feature_matrix(g)\n4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅   5.0   ⋅   1.0\n  ⋅    ⋅   5.0   ⋅\n 5.0   ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅\n\n\nGraph with multi-dimensional features : \n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,4], hcat(3*ones(4), 4*ones(4)));\n\njulia> feature_matrix(g, 2)\n4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅   4.0   ⋅   4.0\n  ⋅    ⋅   4.0   ⋅\n 4.0   ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/feature_graph.html#MultiFlows.scale_features-Union{Tuple{N}, Tuple{T}, Tuple{FeatureDiGraph{T, N}, N}} where {T<:Number, N}","page":"Feature Graph","title":"MultiFlows.scale_features","text":"scale_features(g::FeatureDiGraph{T,N}, factor::N)\n\nScale the features of the graph by factor. factor should have the same dimension as the edge features.\n\n\n\n\n\n","category":"method"},{"location":"mcf/compact_solver.html#Solving-Compact-Formulation","page":"Solving Compact Formulation","title":"Solving Compact Formulation","text":"","category":"section"},{"location":"mcf/compact_solver.html#Index","page":"Solving Compact Formulation","title":"Index","text":"","category":"section"},{"location":"mcf/compact_solver.html","page":"Solving Compact Formulation","title":"Solving Compact Formulation","text":"Pages = [\"compact_solver.md\"]","category":"page"},{"location":"mcf/compact_solver.html#Full-docs","page":"Solving Compact Formulation","title":"Full docs","text":"","category":"section"},{"location":"mcf/compact_solver.html","page":"Solving Compact Formulation","title":"Solving Compact Formulation","text":"Modules = [MultiFlows]\nPages = [\"compact_solver.jl\"]\n","category":"page"},{"location":"mcf/compact_solver.html#MultiFlows.add_capacity_constraints-Tuple{MCF, JuMP.Model}","page":"Solving Compact Formulation","title":"MultiFlows.add_capacity_constraints","text":"add_capacity_constraints(pb::MCF, model::JuMP.Model)\n\nAdd edge capacity constraints to the JuMP.Model.\n\n\n\n\n\n","category":"method"},{"location":"mcf/compact_solver.html#MultiFlows.add_flow_constraints","page":"Solving Compact Formulation","title":"MultiFlows.add_flow_constraints","text":"add_flow_constraints(pb::MCF, model::JuMP.Model, max_acceptance::Bool=false)\n\nAdd flow conservation constraints to the JuMP model.\n\n\n\n\n\n","category":"function"},{"location":"mcf/compact_solver.html#MultiFlows.add_objective_value","page":"Solving Compact Formulation","title":"MultiFlows.add_objective_value","text":"add_objective_value(pb::MCF, model::JuMP.Model, max_acceptance::Bool=false)\n\nAdd objective value to the JuMP.Model.\n\n\n\n\n\n","category":"function"},{"location":"mcf/compact_solver.html#MultiFlows.create_compact_model-Tuple{MCF}","page":"Solving Compact Formulation","title":"MultiFlows.create_compact_model","text":"create_compact_model(pb::MCF)\n\nCreate JuMP model corresponding to the provided MCF problem pb.\n\n\n\n\n\n","category":"method"},{"location":"mcf/compact_solver.html#MultiFlows.flow_constraint_rhs","page":"Solving Compact Formulation","title":"MultiFlows.flow_constraint_rhs","text":"flow_constraint_rhs(pb::MCF, v::Int64, k::Int64, model::JuMP.Model, max_acceptance::Bool=false)\n\nCompute the flow conservation right hand side value for vertex v and demand k.\n\n\n\n\n\n","category":"function"},{"location":"mcf/compact_solver.html#MultiFlows.solve_compact-Tuple{MCF}","page":"Solving Compact Formulation","title":"MultiFlows.solve_compact","text":"solve_compact(pb::MCF)\n\nSolve the compact formulation with state of the art solver.\n\n\n\n\n\n","category":"method"},{"location":"mcf/io.html#Reading/writing-MCFs","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"","category":"section"},{"location":"mcf/io.html#Index","page":"Reading/writing MCFs","title":"Index","text":"","category":"section"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"Pages = [\"io.md\"]","category":"page"},{"location":"mcf/io.html#MCF-file-formats","page":"Reading/writing MCFs","title":"MCF file formats","text":"","category":"section"},{"location":"mcf/io.html#Reading-CSV-files","page":"Reading/writing MCFs","title":"Reading CSV files","text":"","category":"section"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"MCF instances are stored as two CSV files, a link.csv file containing edge data and a service.csv file containing the demand data. ","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"Example of a link.csv file: ","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"|# LinkId|srcNodeId|dstNodeId|capacity |cost|latency|\n|--------|---------|---------|---------|----|-------|\n|1       |1        |4        |6        |2   |0      |\n|2       |1        |2        |12       |3   |0      |\n|3       |2        |4        |12       |3   |0      |\n|4       |4        |7        |5        |8   |0      |\n|5       |2        |3        |11       |4   |0      |\n|6       |3        |4        |20       |8   |0      |\n|7       |4        |6        |10       |3   |0      |\n|8       |6        |7        |20       |3   |0      |\n|9       |1        |5        |10       |80  |0      |\n|10      |5        |7        |10       |20  |0      |","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"Example of a service.csv file: ","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"|# DemandId|srcNodeId|dstNodeId|amount   |latency|\n|----------|---------|---------|---------|-------|\n|1         |1        |7        |5        |0      |\n|2         |2        |6        |5        |0      |\n|3         |3        |7        |5        |0      |","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"If dirname is the path of a directory containing both files as described in the example above we may load an MCF instance : ","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"julia> pb = load(dirname)\nMCF(nv = 7, ne = 10, nk = 3)\n\tDemand{Int64, Int64}(1, 7, 5)\n\tDemand{Int64, Int64}(2, 6, 5)\n\tDemand{Int64, Int64}(3, 7, 5)\n\njulia> adjacency_matrix(pb.graph)\n7×7 SparseArrays.SparseMatrixCSC{Int64, Int64} with 10 stored entries:\n ⋅  1  ⋅  1  1  ⋅  ⋅\n ⋅  ⋅  1  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  1  1\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"By default the edges in the link.csv file are added only in one direction. Ensuring that edges exist in both directions can be achieved by passing edge_dir = :double to the load function. Note that for each edge that is specified in only one direction within the CSV file, features will be copied.","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"julia> pb = load(dirname, edge_dir=:double)\nMCF(nv = 7, ne = 20, nk = 3)\n\tDemand{Int64, Int64}(1, 7, 5)\n\tDemand{Int64, Int64}(2, 6, 5)\n\tDemand{Int64, Int64}(3, 7, 5)\n\njulia> adjacency_matrix(pb.graph)\n7×7 SparseArrays.SparseMatrixCSC{Int64, Int64} with 20 stored entries:\n ⋅  1  ⋅  1  1  ⋅  ⋅\n 1  ⋅  1  1  ⋅  ⋅  ⋅\n ⋅  1  ⋅  1  ⋅  ⋅  ⋅\n 1  1  1  ⋅  ⋅  1  1\n 1  ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  1  ⋅  ⋅  1\n ⋅  ⋅  ⋅  1  1  1  ⋅","category":"page"},{"location":"mcf/io.html#Saving-instances","page":"Reading/writing MCFs","title":"Saving instances","text":"","category":"section"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"To save an MCF instance to a directory : ","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"julia> save(pb, \"path_to_instance\")","category":"page"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"This will create two files : path_to_instance/link.csv and path_to_instance/service.csv.","category":"page"},{"location":"mcf/io.html#Full-docs","page":"Reading/writing MCFs","title":"Full docs","text":"","category":"section"},{"location":"mcf/io.html","page":"Reading/writing MCFs","title":"Reading/writing MCFs","text":"Modules = [MultiFlows]\nPages = [\"io.jl\"]\n","category":"page"},{"location":"mcf/io.html#MultiFlows.UnknownMultiFlowFormat","page":"Reading/writing MCFs","title":"MultiFlows.UnknownMultiFlowFormat","text":"UnknownMCFFormat Exception\n\nException raised when trying to load instance from unknown file format.\n\n\n\n\n\n","category":"type"},{"location":"mcf/io.html#MultiFlows.is_instance_dir-Tuple{String}","page":"Reading/writing MCFs","title":"MultiFlows.is_instance_dir","text":"is_instance_dir(dirname::String)\n\nCheck if a directory contains files link.csv, service.csv.\n\njulia> save(pb, \"test_instance\")\n(\"test_instance/link.csv\", \"test_instance/service.csv\")\n\njulia> is_instance_dir(\"test_instance\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"mcf/io.html#MultiFlows.load-Tuple{String}","page":"Reading/writing MCFs","title":"MultiFlows.load","text":"load(dirname::String; format=:csv, edge_dir=:single)\n\nLoad MultiFlow problem from file. If format=:csv uses load_csv(dirname::String) (at this time CSV files are the only supported format). edge_dir can be one of the following : \n\n:single : each edge in the input file is interpreted as a directed edge\n:double : each edge in the input file is interpreted as existing in both directions with the same attributes and features\n\n\n\n\n\n","category":"method"},{"location":"mcf/io.html#MultiFlows.load_csv-Tuple{String}","page":"Reading/writing MCFs","title":"MultiFlows.load_csv","text":"load_csv(dirname::String)\n\nLoad MultiFlow instance from CSV files. Default is to search for a link.csv and service.csv file.\n\n\n\n\n\n","category":"method"},{"location":"mcf/io.html#MultiFlows.save-Tuple{MCF, String}","page":"Reading/writing MCFs","title":"MultiFlows.save","text":"save(pb::MCF, dirname::String)\n\nSave MCF instance to dirname. Will create the files <dirname>/link.csv and <dirname>/service.csv. If folder does not exist it will be created.\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#Multi-Commodity-Flow","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"","category":"section"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"MultiFlows.jl offers the MCF interface for creating Multi-Commodity Flow problems. An MCF instance is defined by a capacitated graph and a set of demands. The objective is to find a set of paths that satisfy the demands without exceeding edge capacities.","category":"page"},{"location":"mcf/mcf.html#Formulation","page":"Multi-Commodity Flow","title":"Formulation","text":"","category":"section"},{"location":"mcf/mcf.html#Arc-flow-ormulation","page":"Multi-Commodity Flow","title":"Arc-flow ormulation","text":"","category":"section"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"The problem is defined on a directed graph G = (V A) with edge costs r_a in mathbbR^+ and capacities c_a in mathbbR^+. We are given a set of demands K with each demand having an origin and destination s_k t_k in V and an amount b_k in mathbbR^+. Denoting by x_a^k in 0 1 the amount of flow for demand k circulating through edge a the problem can be written : ","category":"page"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"beginaligned\nminlimits  sumlimits_k in K sumlimits_ain A b_k r_a x_a^k   (1) \ntextst sumlimits_a in delta^+(v) x_a^k - sumlimits_aindelta^-(v) x_a^k = left beginarrayrl 1  textif  v=s_k  -1  textif  v=t_k  0  textotherwise endarray right  forall kin K vin V quad  (2)\nsumlimits_kin K b_k x_a^k leq c_a  forall a in A quad  (3)\nx_a^k in 0 1  forall kin K ain A quad  (4)\nendaligned","category":"page"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"delta^-(u) delta^+(u) respectively denote the set of incomming and outgoing edges at vertex u. Constraint (2) are flow conservation constraints and (3) the edge capacity constraints. When replacing (4) by integer constraints x_a^k in 0 1 we refer to this problem as the Unsplittable Multi-Commodity Flow problem, demands must then by fully routed on a single path.","category":"page"},{"location":"mcf/mcf.html#Path-flow-formulation","page":"Multi-Commodity Flow","title":"Path-flow formulation","text":"","category":"section"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"For each k in K we defined P^k the set of s_k-t_k-paths composed of edges with capacity geater than b_k. For each p in P^k we denote x_p^k the amount of flow circulating on p for demand k. Let P_a^k subset P^k the set of paths that pass through edge a. The Path-flow formulation of the problem is then : ","category":"page"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"beginaligned\nminlimits  sumlimits_k in K sumlimits_pin P^k sumlimits_ain p b_k r_a x_p^k   (5) \ntextst sumlimits_pin P^k x_p^k  = 1  forall kin K quad  (6)\nsumlimits_kin K sumlimits_pin P^k_a b_k x_p^k leq c_a  forall a in A quad  (7)\nx_p^k in 0 1  forall kin K pin P^k quad  (8)\nendaligned","category":"page"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"Constraint (6) ensures that the totality of b_k is routed and (7) that the edge capacities are not exceeded.","category":"page"},{"location":"mcf/mcf.html#Index","page":"Multi-Commodity Flow","title":"Index","text":"","category":"section"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"Pages = [\"mcf.md\"]","category":"page"},{"location":"mcf/mcf.html#Full-docs","page":"Multi-Commodity Flow","title":"Full docs","text":"","category":"section"},{"location":"mcf/mcf.html","page":"Multi-Commodity Flow","title":"Multi-Commodity Flow","text":"Modules = [MultiFlows]\nPages = [\"demand.jl\", \"mcf.jl\", \"solution.jl\"]\n","category":"page"},{"location":"mcf/mcf.html#MultiFlows.AbstractDemand","page":"Multi-Commodity Flow","title":"MultiFlows.AbstractDemand","text":"AbstractDemand\n\nAbstract type subtyped for creating MCF demands.\n\n\n\n\n\n","category":"type"},{"location":"mcf/mcf.html#MultiFlows.Demand","page":"Multi-Commodity Flow","title":"MultiFlows.Demand","text":"MCFDemand\n\nConcrete demand type for MCF problems. A demand has a source node src, destination node dst and an amount amount.\n\n\n\n\n\n","category":"type"},{"location":"mcf/mcf.html#MultiFlows.MCF","page":"Multi-Commodity Flow","title":"MultiFlows.MCF","text":"MCF\n\nMulti-Commodity Flow problem data container. The default expects graph to be a FeatureDiGraph object with 2-dimension edge features [cost, capacity]. demands must be a list of Demand objects.\n\nExamples\n\njulia> g = FeatureDiGraph([1,2,3,1], [2,3,1,3], ones(4,2))\nFeatureDiGraph{Int64, Vector{Float64}}([1, 2, 3, 1], [2, 3, 1, 3], [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0]])\n\njulia> MCF(g, [Demand(1, 2, 1.0)])\nMCF(nv = 3, ne = 4, nk = 1)\n\tDemand{Int64, Float64}(1, 2, 1.0)\n\n\n\n\n\n","category":"type"},{"location":"mcf/mcf.html#MultiFlows.MCF-Union{Tuple{N}, Tuple{T}, Tuple{Graphs.AbstractGraph{T}, Vector{N}, Vector{N}, Array{Demand{T, N}, 1}}} where {T<:Number, N<:Number}","page":"Multi-Commodity Flow","title":"MultiFlows.MCF","text":"MCF(g::AbstractGraph{T}, cost::Vector{N}, capacity::Vector{N}, demands::Vector{Demand{T,N})\n\nCreate a MCF object from an AbstractGraph object, a cost and capacity vector with length ne(g) and a set of demands.\n\nExamples\n\njulia> using Graphs\n\njulia> gr = grid((3,2));\n\njulia> MCF(gr, ones(ne(gr)), ones(ne(gr)), [Demand(1,6,1.0)])\nMCF(nv = 6, ne = 14, nk = 1)\n\tDemand{Int64, Float64}(1, 6, 1.0)\n\ncost, capacity vectors must have same length as ne(gr) : \n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#Base.show-Tuple{IO, MCF}","page":"Multi-Commodity Flow","title":"Base.show","text":"Base.show(io::IO, pb::MCF)\n\nShow MCF object.\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#Graphs.ne-Tuple{MCF}","page":"Multi-Commodity Flow","title":"Graphs.ne","text":"ne(pb::MCF)\n\nNumber of edges in the MCF network.\n\nExamples\n\njulia> ne(pb)\n14\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#Graphs.nv-Tuple{MCF}","page":"Multi-Commodity Flow","title":"Graphs.nv","text":"nv(pb::MCF)\n\nNumber of vertices.\n\nExamples\n\njulia> nv(pb)\n6\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.capacities-Tuple{MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.capacities","text":"capacities(pb::MCF)\n\nReturn edge capacities in a Vector.\n\nExample\n\njulia> x, y = rand(14), rand(14);\n\njulia> pb = MCF(grid((3,2)), x, y, [Demand(1,2,1.)]);\n\njulia> capacities(pb) == y\ntrue\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.capacity_matrix-Tuple{MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.capacity_matrix","text":"capacity_matrix(pb::MCF)\n\nReturn a sparse matrix with dimension (nv(pb), nv(pb)) with values equal to arc capacity.\n\nExamples\n\njulia> capacity_matrix(pb)\n6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 14 stored entries:\n  ⋅   2.0   ⋅   2.0   ⋅    ⋅\n 2.0   ⋅   2.0   ⋅   2.0   ⋅\n  ⋅   2.0   ⋅    ⋅    ⋅   2.0\n 2.0   ⋅    ⋅    ⋅   2.0   ⋅\n  ⋅   2.0   ⋅   2.0   ⋅   2.0\n  ⋅    ⋅   2.0   ⋅   2.0   ⋅\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.cost_matrix-Tuple{MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.cost_matrix","text":"cost_matrix(pb::MCF)\n\nReturn a sparse matrix with dimension (nv(pb), nv(pb)) with values equal to arc costs.\n\nExamples\n\njulia> cost_matrix(pb)\n6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 14 stored entries:\n  ⋅   1.0   ⋅   1.0   ⋅    ⋅ \n 1.0   ⋅   1.0   ⋅   1.0   ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅   1.0\n 1.0   ⋅    ⋅    ⋅   1.0   ⋅ \n  ⋅   1.0   ⋅   1.0   ⋅   1.0\n  ⋅    ⋅   1.0   ⋅   1.0   ⋅ \n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.costs-Tuple{MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.costs","text":"costs(pb::MCF)\n\nReturn edge costs in a Vector.\n\nExample\n\njulia> x, y = rand(14), rand(14);\n\njulia> pb = MCF(grid((3,2)), x, y, [Demand(1,2,1.)]);\n\njulia> costs(pb) == x\ntrue\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.demands-Union{Tuple{N}, Tuple{T}, Tuple{MCF{T, N}, T, T}} where {T, N}","page":"Multi-Commodity Flow","title":"MultiFlows.demands","text":"demands(pb::MCF{T,N}, s::T, t::T)\n\nGet demands with origin and destination s,t.\n\nExample\n\njulia> demands(pb, 1, 2)\n1-element Vector{Demand{Int64, Float64}}:\n Demand{Int64, Float64}(1, 2, 1.0)\n\njulia> demands(pb, 2, 1)\nDemand{Int64, Float64}[]\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.has_demand-Union{Tuple{N}, Tuple{T}, Tuple{MCF{T, N}, T, T}} where {T, N}","page":"Multi-Commodity Flow","title":"MultiFlows.has_demand","text":"has_demand(pb::MCF{T,N}, s::T, d::T)\n\nCheck if problem has a demand originating at vertex s and with destination d.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(7), ones(7), [Demand(1,2,1.)]);\n\njulia> has_demand(pb, 1, 2)\ntrue\n\njulia> has_demand(pb, 2, 1)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.nk-Tuple{MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.nk","text":"nk(pb::MCF)\n\nNumber of demands in the MCF instance.\n\nExamples\n\njulia> nk(pb)\n1\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.normalize-Tuple{MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.normalize","text":"normalize(pb::MCF)\n\nNormalize MCF instance. Costs are scaled by 1 / max(pb.cost), capacity and demand amount are scaled by 1 / max(max(pb.capacity), max(pb.amount)).\n\nExample\n\njulia> pb = MCF(grid((3,2)), collect(1.0:7.0), collect(0.0:2:13.0), [Demand(1,6,10.0)])\nMCF(nv = 6, ne = 14, nk = 1)\n\tDemand{Int64, Float64}(1, 6, 10.0)\n\njulia> pbn = normalize(pb)\nMCF(nv = 6, ne = 14, nk = 1)\n\tDemand{Int64, Float64}(1, 6, 0.8333333333333333)\n\njulia> cost_matrix(pbn)\n6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 14 stored entries:\n  ⋅        0.142857   ⋅        0.285714   ⋅         ⋅ \n 0.142857   ⋅        0.428571   ⋅        0.571429   ⋅ \n  ⋅        0.428571   ⋅         ⋅         ⋅        0.714286\n 0.285714   ⋅         ⋅         ⋅        0.857143   ⋅ \n  ⋅        0.571429   ⋅        0.857143   ⋅        1.0\n  ⋅         ⋅        0.714286   ⋅        1.0        ⋅ \n\njulia> capacity_matrix(pbn)\n6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 14 stored entries:\n  ⋅        0.0        ⋅        0.166667   ⋅         ⋅ \n 0.0        ⋅        0.333333   ⋅        0.5        ⋅ \n  ⋅        0.333333   ⋅         ⋅         ⋅        0.666667\n 0.166667   ⋅         ⋅         ⋅        0.833333   ⋅ \n  ⋅        0.5        ⋅        0.833333   ⋅        1.0\n  ⋅         ⋅        0.666667   ⋅        1.0        ⋅ \n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.scale-Union{Tuple{MCF{T, N}}, Tuple{N}, Tuple{T}, Tuple{MCF{T, N}, Any}, Tuple{MCF{T, N}, Any, Any}} where {T, N}","page":"Multi-Commodity Flow","title":"MultiFlows.scale","text":"scale(pb::MCF, cost_factor=1.0, capacity_factor=1.0)\n\nReturn a new MCF instance with costs scaled by a cost_factor, capacity and demand amounts scaled by capacity_factor.\n\nExample\n\njulia> pb1 = scale(pb, 1.5, 3)\nMCF(nv = 6, ne = 14, nk = 1)\n\tDemand{Int64, Float64}(1, 6, 3.0)\n\njulia> cost_matrix(pb1)\n6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 14 stored entries:\n  ⋅   1.5   ⋅   1.5   ⋅    ⋅\n 1.5   ⋅   1.5   ⋅   1.5   ⋅\n  ⋅   1.5   ⋅    ⋅    ⋅   1.5\n 1.5   ⋅    ⋅    ⋅   1.5   ⋅\n  ⋅   1.5   ⋅   1.5   ⋅   1.5\n  ⋅    ⋅   1.5   ⋅   1.5   ⋅\n\n\njulia> capacity_matrix(pb1)\n6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 14 stored entries:\n  ⋅   6.0   ⋅   6.0   ⋅    ⋅\n 6.0   ⋅   6.0   ⋅   6.0   ⋅\n  ⋅   6.0   ⋅    ⋅    ⋅   6.0\n 6.0   ⋅    ⋅    ⋅   6.0   ⋅\n  ⋅   6.0   ⋅   6.0   ⋅   6.0\n  ⋅    ⋅   6.0   ⋅   6.0   ⋅\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.scale_demands-Tuple{MCF, Any}","page":"Multi-Commodity Flow","title":"MultiFlows.scale_demands","text":"scale_demands(pb::MCF, factor)\n\nScale the amount of the demands by factor. Returns new list of demands.\n\nExample\n\njulia> dems = scale_demands(pb, 2)\n1-element Vector{Demand{Int64, Float64}}:\n Demand{Int64, Float64}(1, 6, 2.0)\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.weight_matrix","page":"Multi-Commodity Flow","title":"MultiFlows.weight_matrix","text":"weight_matrix(pb::MCF, idx::Int64=1)\n\nReturns a (nv(pb), nv(pb)) matrix with elements equal to edge features corresponding to idx.\n\nExamples\n\njulia> pb = MCF(grid((3,2)), ones(7), 2*ones(7), [Demand(1,6,1.0)]);\n\njulia> weight_matrix(pb)\n6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 14 stored entries:\n  ⋅   1.0   ⋅   1.0   ⋅    ⋅\n 1.0   ⋅   1.0   ⋅   1.0   ⋅\n  ⋅   1.0   ⋅    ⋅    ⋅   1.0\n 1.0   ⋅    ⋅    ⋅   1.0   ⋅\n  ⋅   1.0   ⋅   1.0   ⋅   1.0\n  ⋅    ⋅   1.0   ⋅   1.0   ⋅\n\n\n\n\n\n\n\n","category":"function"},{"location":"mcf/mcf.html#MultiFlows.MCFSolution","page":"Multi-Commodity Flow","title":"MultiFlows.MCFSolution","text":"MCFSolution\n\nContainer representing the solution of an MCF problem. Contains a list of paths such that sol.paths[k] contains the paths used to route demand k and flows[k] are the flow values\n\n\n\n\n\n","category":"type"},{"location":"mcf/mcf.html#Base.show-Tuple{IO, MCFSolution}","page":"Multi-Commodity Flow","title":"Base.show","text":"Base.show(sol::MCFSolution)\n\nShow solutions.\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.arc_flow_value-Tuple{MCFSolution, MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.arc_flow_value","text":"arc_flow_value(sol::MCFSolution, pb::MCF)\n\nReturns a (nk(pb), ne(pb)) sized matrix where coefficients x[k,a] is the amount of flow for demand k circulating through a.\n\nExample\n\njulia> pb = MCF(grid((3,2)), collect(1:7.), collect(10:16.), [Demand(1,2,1.)]);\n\njulia> sol = MCFSolution([[VertexPath([1,2]), VertexPath([1,4,5,2])]], [[.5, .5]]);\n\njulia> arc_flow_value(sol, pb)\n1×14 Matrix{Float64}:\n 0.5  0.5  0.0  0.0  0.0  0.5  0.0  0.0  0.0  0.0  0.5  0.0  0.0  0.0\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.is_feasible-Tuple{MCFSolution, MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.is_feasible","text":"is_feasible(sol::MCFSolution, pb::MCF)\n\nCheck if the solution is feasible, has to be a valid solution for the problem and the total amount circulating on the graph must not be greater than the edge capacities and all demands must be routed entirely.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(14), ones(14), [Demand(1,2,2.)]);\n\njulia> sol = MCFSolution([[VertexPath([1,4,5,2])]], [[1.]]);\n\njulia> is_feasible(sol, pb)\nfalse\n\njulia> sol = MCFSolution([[VertexPath([1,2]), VertexPath([1,4,5,2])]], [[.5, .5]]);\n\njulia> is_feasible(sol, pb)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.is_solution-Tuple{MCFSolution, MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.is_solution","text":"is_solution(sol::MCFSolution, pb::MCF)\n\nCheck if sol is a solution for problem pb. Checks if length(paths) == length(flows) == nk(pb), that each path is a valid path on the graph and has the correct endpoints, and that sum(flows[k]) <= 1.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(7), ones(7), [Demand(1,2,1.)])\nMCF(nv = 6, ne = 14, nk = 1)\n\tDemand{Int64, Float64}(1, 2, 1.0)\n\njulia> sol = MCFSolution([[VertexPath([1,2])]], [[1.]])\nMCFSolution\n\tDemand k = 1\n\t\t1.0 on VertexPath{Int64}([1, 2])\n\njulia> is_solution(sol, pb)\ntrue\n\njulia> sol = MCFSolution([[VertexPath([1,2]), VertexPath([1,4,5,2])]], [[.5, .5]])\nMCFSolution\n\tDemand k = 1\n\t\t0.5 on VertexPath{Int64}([1, 2])\n\t\t0.5 on VertexPath{Int64}([1, 4, 5, 2])\n\njulia> is_solution(sol, pb)\ntrue\n\n\nLets create invalid solutions : \n\njulia> # path is not valid\n\njulia> is_solution(MCFSolution([[VertexPath([1,3])]], [[1.]]), pb)\nfalse\n\njulia> # total flow for demand 1 is greater than 1\n\njulia> is_solution(MCFSolution([[VertexPath([1,2])]], [[2.]]), pb)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.objective_value-Tuple{MCFSolution, MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.objective_value","text":"objective_value(sol::MCFSolution, pb::MCF)\n\nCompute the objective value of sol. \n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(14), ones(14), [Demand(1,2,2.)]);\n\njulia> sol = MCFSolution([[VertexPath([1,4,5,2])]], [[1.]]);\n\njulia> objective_value(sol, pb)\n6.0\n\njulia> sol = MCFSolution([[VertexPath([1,2]), VertexPath([1,4,5,2])]], [[.5, .5]]);\n\njulia> objective_value(sol, pb)\n4.0\n\n\n\n\n\n","category":"method"},{"location":"mcf/mcf.html#MultiFlows.used_capacity-Tuple{MCFSolution, MCF}","page":"Multi-Commodity Flow","title":"MultiFlows.used_capacity","text":"used_capacity(sol::MCFSolution, pb::MCF)\n\nCompute total edge capacity used by the solution.\n\nExample\n\njulia> pb = MCF(grid((3,2)), ones(14), ones(14), [Demand(1,2,2.)]);\n\njulia> sol = MCFSolution([[VertexPath([1,4,5,2])]], [[1.]]);\n\njulia> used_capacity(sol, pb)\n14-element Vector{Float64}:\n 0.0\n 2.0\n 0.0\n 0.0\n 0.0\n 2.0\n 0.0\n 0.0\n 0.0\n 0.0\n 2.0\n 0.0\n 0.0\n 0.0\n\n\n\n\n\n\n","category":"method"},{"location":"mcf/plot.html#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"mcf/plot.html","page":"Plotting","title":"Plotting","text":"Plotting MCF problems is done by using the GraphPlot.jl package. A plot can be generated through use of the mcfplot(pb::MCF, layout::Function=spring_layout) function. ","category":"page"},{"location":"mcf/plot.html","page":"Plotting","title":"Plotting","text":"julia> pb = load(\"instances/toytests/test1/\", edge_dir=:single)\nMCF(nv = 7, ne = 10, nk = 3)\n\tDemand{Int64, Int64}(1, 7, 5)\n\tDemand{Int64, Int64}(2, 6, 5)\n\tDemand{Int64, Int64}(3, 7, 5)\n\njulia> # draw and save figure\n\njulia> draw(PNG(\"test1.png\", 16cm, 16cm), mcfplot(pb))","category":"page"},{"location":"mcf/plot.html","page":"Plotting","title":"Plotting","text":"(Image: toytesttest1)","category":"page"},{"location":"mcf/plot.html#Index","page":"Plotting","title":"Index","text":"","category":"section"},{"location":"mcf/plot.html","page":"Plotting","title":"Plotting","text":"Pages = [\"plot.md\"]","category":"page"},{"location":"mcf/plot.html#Full-docs","page":"Plotting","title":"Full docs","text":"","category":"section"},{"location":"mcf/plot.html","page":"Plotting","title":"Plotting","text":"Modules = [MultiFlows]\nPages = [\"plot.jl\"]\n","category":"page"},{"location":"mcf/plot.html#MultiFlows.mcfplot","page":"Plotting","title":"MultiFlows.mcfplot","text":"mcfplot(pb::MCF, layout::Function=spring_layout;\n        minedgelinewidth=1.0,\n        maxedgelinewidth=10.0,\n)\n\nPlot MCF problem. MultiFlows.jl uses the GraphPlot.jl package for generating graph plots. Edge line widths are scaled onto [minedgelinewidth, maxedgelinewidth] as a function of edge capacity and demand amounts.\n\n\n\n\n\n","category":"function"},{"location":"core_functions/path.html#Paths","page":"Paths","title":"Paths","text":"","category":"section"},{"location":"core_functions/path.html#Index","page":"Paths","title":"Index","text":"","category":"section"},{"location":"core_functions/path.html","page":"Paths","title":"Paths","text":"Pages = [\"path.md\"]","category":"page"},{"location":"core_functions/path.html#Full-docs","page":"Paths","title":"Full docs","text":"","category":"section"},{"location":"core_functions/path.html","page":"Paths","title":"Paths","text":"Modules = [MultiFlows]\nPages = [\"path.jl\"]\n","category":"page"},{"location":"core_functions/path.html#MultiFlows.AbstractPath","page":"Paths","title":"MultiFlows.AbstractPath","text":"AbstractPath\n\nAbstract type for representing paths in a graph.\n\n\n\n\n\n","category":"type"},{"location":"core_functions/path.html#MultiFlows.VertexPath","page":"Paths","title":"MultiFlows.VertexPath","text":"VertexPath\n\nConcrete type for paths composed of a sequence of vertex indices.\n\nExample\n\njulia> g = grid((3,2))\n{6, 7} undirected simple Int64 graph\n\njulia> ds = dijkstra_shortest_paths(g, 1);\n\njulia> p = VertexPath(enumerate_paths(ds, 6))\nVertexPath{Int64}([1, 2, 5, 6])\n\n\n\n\n\n","category":"type"},{"location":"core_functions/path.html#Base.isempty-Tuple{VertexPath}","page":"Paths","title":"Base.isempty","text":"Base.isempty(p::VertexPath)\n\nCheck if the path is empty.\n\n\n\n\n\n","category":"method"},{"location":"core_functions/path.html#Graphs.edges-Tuple{VertexPath}","page":"Paths","title":"Graphs.edges","text":"Graphs.edges(p::VertexPath)\n\nReturn edge iterator of the path.\n\nExample\n\njulia> p = VertexPath([1,2,3])\nVertexPath{Int64}([1, 2, 3])\n\njulia> edges(p)\n2-element Vector{Tuple{Int64, Int64}}:\n (1, 2)\n (2, 3)\n\n\n\n\n\n","category":"method"},{"location":"core_functions/path.html#MultiFlows.edge_indices-Tuple{VertexPath, Graphs.AbstractGraph}","page":"Paths","title":"MultiFlows.edge_indices","text":"edge_indices(p::VertexPath, g::AbstractGraph)\n\nGet list of edge indices corresponding to the path.\n\nExample\n\njulia> p = VertexPath([1,2,5,6]);\n\njulia> edge_indices(p, g)\n3-element Vector{Int64}:\n 1\n 4\n 7\n\njulia> collect(edges(g))[edge_indices(p,g)]\n3-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 2 => 5\n Edge 5 => 6\n\n\n\n\n\n\n","category":"method"},{"location":"core_functions/path.html#MultiFlows.is_path-Tuple{VertexPath, Graphs.AbstractGraph}","page":"Paths","title":"MultiFlows.is_path","text":"is_path(p::VertexPath, g::AbstractGraph)\n\nCheck if p is a valid path in graph g.\n\nExample\n\njulia> g = grid((3,2));\n\njulia> p = VertexPath([1,2,5,6]);\n\njulia> is_path(p, g)\ntrue\n\njulia> is_path(p, grid((2,1)))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"core_functions/path.html#MultiFlows.is_path-Union{Tuple{T}, Tuple{VertexPath{T}, T, T}} where T","page":"Paths","title":"MultiFlows.is_path","text":"is_path(p::VertexPath{T}, s::T, t::T)\n\nCheck if path is an s-t-path.\n\nExample\n\njulia> p = VertexPath([1,2,3]);\n\njulia> is_path(p, 1, 2)\nfalse\n\njulia> is_path(p, 1, 3)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"core_functions/path.html#MultiFlows.path_weight-Tuple{VertexPath, Graphs.AbstractGraph}","page":"Paths","title":"MultiFlows.path_weight","text":"path_weight(p::VertexPath, g::AbstractGraph; aggr::Function=sum, dstmx=weights(g))\n\nCompute the weight of the path in graph g. \n\nExample\n\njulia> path_weight(p, g)\n3\n\nYou may provide a different weight matrix \n\njulia> w = zeros(nv(g), nv(g));\n\njulia> w[Bool.(adjacency_matrix(g))] .= 1:2*ne(g);\n\njulia> w\n6×6 Matrix{Float64}:\n 0.0  3.0  0.0  8.0   0.0   0.0\n 1.0  0.0  6.0  0.0  10.0   0.0\n 0.0  4.0  0.0  0.0   0.0  13.0\n 2.0  0.0  0.0  0.0  11.0   0.0\n 0.0  5.0  0.0  9.0   0.0  14.0\n 0.0  0.0  7.0  0.0  12.0   0.0\n\njulia> path_weight(p, g, dstmx=w)\n27.0\n\njulia> path_weight(p, g, dstmx=w, aggr=minimum)\n3.0\n\n\n\n\n\n","category":"method"},{"location":"mcf/heuristic_solver.html#Heuristics","page":"Heuristics","title":"Heuristics","text":"","category":"section"},{"location":"mcf/heuristic_solver.html","page":"Heuristics","title":"Heuristics","text":"Heuristics for solving MCF problems.","category":"page"},{"location":"mcf/heuristic_solver.html","page":"Heuristics","title":"Heuristics","text":"julia> pb = load(\"instances/toytests/test1/\", edge_dir=:single)\nMCF(nv = 7, ne = 10, nk = 3)\n\tDemand{Int64, Int64}(1, 7, 5)\n\tDemand{Int64, Int64}(2, 6, 5)\n\tDemand{Int64, Int64}(3, 7, 5)\n\njulia> solve_shortest_paths(pb)\nMCFSolution\n\tDemand k = 1\n\t\t1.0 on VertexPath{Int64}([1, 4, 6, 7])\n\tDemand k = 2\n\t\t1.0 on VertexPath{Int64}([2, 4, 6])\n\tDemand k = 3\n\t\t1.0 on VertexPath{Int64}([3, 4, 7])\n","category":"page"},{"location":"mcf/heuristic_solver.html","page":"Heuristics","title":"Heuristics","text":"By default solve_shortest_paths searches for a path for each demand, taking them in the order in wich they appear in pb.demands. The demand_permutation keyword arguments allows users to apply a different ordering scheme : ","category":"page"},{"location":"mcf/heuristic_solver.html","page":"Heuristics","title":"Heuristics","text":"julia> solve_shortest_paths(pb, demand_permutation=shuffle)\nMCFSolution\n\tDemand k = 1\n\t\t1.0 on VertexPath{Int64}([1, 4, 6, 7])\n\tDemand k = 2\n\t\t1.0 on VertexPath{Int64}([2, 4, 6])\n\tDemand k = 3\n\t\t1.0 on VertexPath{Int64}([3, 4, 7])\n","category":"page"},{"location":"mcf/heuristic_solver.html#Index","page":"Heuristics","title":"Index","text":"","category":"section"},{"location":"mcf/heuristic_solver.html","page":"Heuristics","title":"Heuristics","text":"Pages = [\"heuristic_solver.md\"]","category":"page"},{"location":"mcf/heuristic_solver.html#Full-docs","page":"Heuristics","title":"Full docs","text":"","category":"section"},{"location":"mcf/heuristic_solver.html","page":"Heuristics","title":"Heuristics","text":"Modules = [MultiFlows]\nPages = [\"heuristic_solver.jl\"]\n","category":"page"},{"location":"mcf/heuristic_solver.html#MultiFlows.solve_shortest_paths-Union{Tuple{MCF{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Heuristics","title":"MultiFlows.solve_shortest_paths","text":"solve_shortest_paths(pb::MCF)\n\nSolve an MCF instance by taking the shortest path for each demand.\n\n\n\n\n\n","category":"method"},{"location":"index.html#MultiFlows.jl-Documentation","page":"MultiFlows.jl Documentation","title":"MultiFlows.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"MultiFlows.jl Documentation","title":"MultiFlows.jl Documentation","text":"Modules = [MultiFlows]\nPages = [\"MultiFlows.jl\"]\n","category":"page"},{"location":"index.html#MultiFlows.MultiFlows","page":"MultiFlows.jl Documentation","title":"MultiFlows.MultiFlows","text":"MultiFlows\n\nMultiFlows package documentation.\n\n\n\n\n\n","category":"module"}]
}
